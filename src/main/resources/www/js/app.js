var app = angular.module('PrettyPR', ['ngMaterial']);

app.controller('AppCtrl', ['$scope', '$mdSidenav', '$http', function ($scope, $mdSidenav, $http) {
    $scope.pr = {};
    $scope.prettyPR = {
  "pullrequest": {
    "changes": [
      {
        "oldFile": "package spoon.test.properties;\n\nimport org.junit.Test;\nimport spoon.Launcher;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.reflect.factory.Factory;\n\nimport java.io.File;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class PropertiesTest {\n\n\t@Test\n\tpublic void testNonExistingDirectory() throws Exception {\n\t\tFile tempFile = File.createTempFile(\"SPOON\", \"SPOON\");\n\t\ttempFile.delete();\n\n\t\tLauncher spoon = new Launcher();\n\t\tFactory factory = spoon.createFactory();\n\t\tfactory.getEnvironment().setXmlRootFolder(tempFile);\n\t\tSpoonCompiler compiler = spoon.createCompiler(\n\t\t\t\tfactory,\n\t\t\t\tSpoonResourceHelper\n\t\t\t\t\t\t.resources(\n\t\t\t\t\t\t\t\t\"./src/test/java/spoon/test/properties/Sample.java\"\n\t\t\t\t\t\t));\n\t\tcompiler.build();\n\n\t\tcompiler.process(Arrays.asList(SimpleProcessor.class.getName()));\n\t\tassertEquals(factory.getEnvironment().getErrorCount(), 0);\n\t}\n\n}",
        "newFile": "package spoon.test.properties;\n\nimport org.junit.Test;\nimport spoon.Launcher;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.reflect.factory.Factory;\n\nimport java.io.File;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class PropertiesTest {\n\n\t@Test\n\tpublic void testNonExistingDirectory() throws Exception {\n\t\tFile tempFile = File.createTempFile(\"SPOON\", \"SPOON\");\n\t\ttempFile.delete();\n\n\t\tLauncher spoon = new Launcher();\n\t\tFactory factory = spoon.createFactory();\n\t\tfactory.getEnvironment().setXmlRootFolder(tempFile);\n\t\tSpoonCompiler compiler = spoon.createCompiler(\n\t\t\t\tfactory,\n\t\t\t\tSpoonResourceHelper\n\t\t\t\t\t\t.resources(\n\t\t\t\t\t\t\t\t\"./src/test/java/spoon/test/properties/Sample.java\"\n\t\t\t\t\t\t));\n\t\tcompiler.build();\n\n\t\tcompiler.instantiateAndProcess(Arrays.asList(SimpleProcessor.class.getName()));\n\t\tassertEquals(factory.getEnvironment().getErrorCount(), 0);\n\t}\n\n}",
        "location": {
          "path": "src/test/java/spoon/test/properties/PropertiesTest.java",
          "type": "Test",
          "class": "spoon.test.properties.PropertiesTest"
        }
      },
      {
        "oldFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\n\npackage spoon;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\nimport spoon.compiler.SpoonResource;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\n\n/**\n * Responsible for building a spoon model from Java source code.\n *\n * <p>\n * The Spoon model (see {@link Factory} is built from input sources given as\n * files. Use {@link #build()} to create the Spoon model.\n * Once the model is built and stored in the factory, it\n * can be processed by using a {@link #process(List)}.\n * <\/p>\n *\n * <p>\n * Create an instance of the default implementation of the Spoon compiler by\n * using {@link spoon.Launcher#createCompiler()}. For example:\n * <\/p>\n */\npublic interface SpoonModelBuilder {\n\n\t/**\n\t * Adds a file/directory to be built. By default, the files could be Java\n\t * source files or Jar files. Directories are processed recursively.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addInputSource(File source);\n\n\t/**\n\t * Sets the output directory for binary generated.\n\t *\n\t * @param binaryOutputDirectory\n\t * \t\t{@link File} for binary output directory.\n\t */\n\tvoid setBinaryOutputDirectory(File binaryOutputDirectory);\n\n\t/**\n\t * Gets the binary output directory of the compiler.\n\t */\n\tFile getBinaryOutputDirectory();\n\n\t/**\n\t * Sets the output directory for source generated.\n\t *\n\t * @param outputDirectory\n\t * \t\t{@link File} for output directory.\n\t */\n\tvoid setSourceOutputDirectory(File outputDirectory);\n\n\t/**\n\t * Gets the output directory of this compiler.\n\t */\n\tFile getSourceOutputDirectory();\n\n\t/**\n\t * Adds a file/directory (as a CtResource) to be built. By default, the\n\t * files could be Java source files or Jar files. Directories are processed\n\t * recursively.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addInputSource(SpoonResource source);\n\n\t/**\n\t * Gets all the files/directories given as input sources to this builder\n\t * (see {@link #addInputSource(File)}).\n\t */\n\tSet<File> getInputSources();\n\n\t/**\n\t * Adds a file/directory to be used to build templates. By default, the\n\t * files should be Java source files or Jar files containing the sources.\n\t * Directories are processed recursively. Templates are set apart from the\n\t * program to be processed for logical reasons. However, if a template was\n\t * needed to be processed, it could be added as an input source.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addTemplateSource(File source);\n\n\t/**\n\t * Adds a file/directory (as a CtResource) to be used to build templates. By\n\t * default, the files should be Java source files or Jar files containing\n\t * the sources. Directories are processed recursively. Templates are set\n\t * apart from the program to be processed for logical reasons. However, if a\n\t * template was needed to be processed, it could be added as an input\n\t * source.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addTemplateSource(SpoonResource source);\n\n\t/**\n\t * Gets all the files/directories given as template sources to this builder\n\t * (see {@link #addTemplateSource(File)}).\n\t */\n\tSet<File> getTemplateSources();\n\n\tvoid addInputSources(List<SpoonResource> resources);\n\n\tvoid addTemplateSources(List<SpoonResource> resources);\n\n\t/**\n\t * Builds the program's model with this compiler's factory and stores the\n\t * result into this factory. Note that this method should only be used once\n\t * on a given factory.\n\t *\n\t * @return true if the Java was successfully compiled with the core Java\n\t * compiler, false if some errors were encountered while compiling\n\t * @throws spoon.SpoonException\n\t * \t\twhen a building problem occurs\n\t * @see #getSourceClasspath()\n\t * @see #getTemplateClasspath()\n\t */\n\tboolean build();\n\n\t/**\n\t * Processes the Java model with the given processors.\n\t */\n\tvoid process(List<String> processorTypes);\n\n\t/**\n\t * Processes the Java model with the given processors.\n\t */\n\tvoid process(Collection<Processor<? extends CtElement>> processors);\n\n\t/**\n\t * Generates the source code associated to the classes stored in this\n\t * compiler's factory. The source code is generated in the directory given\n\t * by {@link #getSourceOutputDirectory()}.\n\t *\n\t * @param outputType\n\t * \t\tthe output method\n\t */\n\tvoid generateProcessedSourceFiles(OutputType outputType);\n\n\t/**\n\t * Generates the bytecode associated to the classes stored in this\n\t * compiler's factory. The bytecode is generated in the directory given by\n\t * {@link #getBinaryOutputDirectory()}.\n\t *\n\t * @see #getSourceClasspath()\n\t */\n\tboolean compile();\n\n\t/**\n\t * Generates the bytecode by compiling the input sources. The bytecode is\n\t * generated in the directory given by {@link #getBinaryOutputDirectory()}.\n\t *\n\t * @see #getSourceClasspath()\n\t */\n\tboolean compileInputSources();\n\n\t/**\n\t * Gets the classpath that is used to build/compile the input sources.\n\t *\n\t * @see #compileInputSources()\n\t * @see #build()\n\t * @see #compile()\n\t */\n\tString[] getSourceClasspath();\n\n\t/**\n\t * Sets the classpath that is used to build/compile the input sources.\n\t *\n\t * Each element of the array is either a jar file or a folder containing bytecode files.\n\t */\n\tvoid setSourceClasspath(String... classpath);\n\n\t/**\n\t * Gets the classpath that is used to build the template sources.\n\t *\n\t * See {@link #setSourceClasspath} for the meaning of the returned string.\n\t */\n\tString[] getTemplateClasspath();\n\n\t/**\n\t * Sets the classpath that is used to build the template sources.\n\t */\n\tvoid setTemplateClasspath(String... classpath);\n\n\t/**\n\t * Sets this compiler to optimize the model building process by ignoring\n\t * files that has not be modified since the latest source code generation.\n\t */\n\tvoid setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles);\n\n\t/**\n\t * When {@link #setBuildOnlyOutdatedFiles(boolean)} is true, adds a resource\n\t * to the forced-to-be-built list. All the files added here will be build\n\t * even if no changes are detected on the file system. This list has no\n\t * impacts if @link #setBuildOnlyOutdatedFiles(boolean)} is false.\n\t */\n\tvoid forceBuild(SpoonResource source);\n\n\t/**\n\t * Sets the encoding to use when different from the system encoding.\n\t */\n\tvoid setEncoding(String encoding);\n\n\t/**\n\t * Gets the encoding used by this compiler. Null means that it uses the\n\t * system encoding.\n\t */\n\tString getEncoding();\n\n\t/**\n\t * Returns the working factory\n\t */\n\tFactory getFactory();\n\n}",
        "newFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\n\npackage spoon;\n\nimport spoon.compiler.SpoonResource;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Responsible for building a spoon model from Java source code.\n *\n * <p>\n * The Spoon model (see {@link Factory} is built from input sources given as\n * files. Use {@link #build()} to create the Spoon model.\n * Once the model is built and stored in the factory, it\n * can be processed by using a {@link #instantiateAndProcess(List)}.\n * <\/p>\n *\n * <p>\n * Create an instance of the default implementation of the Spoon compiler by\n * using {@link spoon.Launcher#createCompiler()}. For example:\n * <\/p>\n */\npublic interface SpoonModelBuilder {\n\n\t/**\n\t * Adds a file/directory to be built. By default, the files could be Java\n\t * source files or Jar files. Directories are processed recursively.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addInputSource(File source);\n\n\t/**\n\t * Sets the output directory for binary generated.\n\t *\n\t * @param binaryOutputDirectory\n\t * \t\t{@link File} for binary output directory.\n\t */\n\tvoid setBinaryOutputDirectory(File binaryOutputDirectory);\n\n\t/**\n\t * Gets the binary output directory of the compiler.\n\t */\n\tFile getBinaryOutputDirectory();\n\n\t/**\n\t * Sets the output directory for source generated.\n\t *\n\t * @param outputDirectory\n\t * \t\t{@link File} for output directory.\n\t */\n\tvoid setSourceOutputDirectory(File outputDirectory);\n\n\t/**\n\t * Gets the output directory of this compiler.\n\t */\n\tFile getSourceOutputDirectory();\n\n\t/**\n\t * Adds a file/directory (as a CtResource) to be built. By default, the\n\t * files could be Java source files or Jar files. Directories are processed\n\t * recursively.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addInputSource(SpoonResource source);\n\n\t/**\n\t * Gets all the files/directories given as input sources to this builder\n\t * (see {@link #addInputSource(File)}).\n\t */\n\tSet<File> getInputSources();\n\n\t/**\n\t * Adds a file/directory to be used to build templates. By default, the\n\t * files should be Java source files or Jar files containing the sources.\n\t * Directories are processed recursively. Templates are set apart from the\n\t * program to be processed for logical reasons. However, if a template was\n\t * needed to be processed, it could be added as an input source.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addTemplateSource(File source);\n\n\t/**\n\t * Adds a file/directory (as a CtResource) to be used to build templates. By\n\t * default, the files should be Java source files or Jar files containing\n\t * the sources. Directories are processed recursively. Templates are set\n\t * apart from the program to be processed for logical reasons. However, if a\n\t * template was needed to be processed, it could be added as an input\n\t * source.\n\t *\n\t * @param source\n\t * \t\tfile or directory to add\n\t */\n\tvoid addTemplateSource(SpoonResource source);\n\n\t/**\n\t * Gets all the files/directories given as template sources to this builder\n\t * (see {@link #addTemplateSource(File)}).\n\t */\n\tSet<File> getTemplateSources();\n\n\tvoid addInputSources(List<SpoonResource> resources);\n\n\tvoid addTemplateSources(List<SpoonResource> resources);\n\n\t/**\n\t * Builds the program's model with this compiler's factory and stores the\n\t * result into this factory. Note that this method should only be used once\n\t * on a given factory.\n\t *\n\t * @return true if the Java was successfully compiled with the core Java\n\t * compiler, false if some errors were encountered while compiling\n\t * @throws spoon.SpoonException\n\t * \t\twhen a building problem occurs\n\t * @see #getSourceClasspath()\n\t * @see #getTemplateClasspath()\n\t */\n\tboolean build();\n\n\t/**\n\t * Processes the Java model with the given processors.\n\t * @see #instantiateAndProcess(List)\n\t */\n\t@Deprecated\n\tvoid process(List<String> processorTypes);\n\n\t/**\n\t * Takes a list of fully qualified name processors and instantiates them to process\n\t * the Java model.\n\t */\n\tvoid instantiateAndProcess(List<String> processors);\n\n\t/**\n\t * Processes the Java model with the given processors.\n\t */\n\tvoid process(Collection<Processor<? extends CtElement>> processors);\n\n\t/**\n\t * Generates the source code associated to the classes stored in this\n\t * compiler's factory. The source code is generated in the directory given\n\t * by {@link #getSourceOutputDirectory()}.\n\t *\n\t * @param outputType\n\t * \t\tthe output method\n\t */\n\tvoid generateProcessedSourceFiles(OutputType outputType);\n\n\t/**\n\t * Generates the bytecode associated to the classes stored in this\n\t * compiler's factory. The bytecode is generated in the directory given by\n\t * {@link #getBinaryOutputDirectory()}.\n\t *\n\t * @see #getSourceClasspath()\n\t */\n\tboolean compile();\n\n\t/**\n\t * Generates the bytecode by compiling the input sources. The bytecode is\n\t * generated in the directory given by {@link #getBinaryOutputDirectory()}.\n\t *\n\t * @see #getSourceClasspath()\n\t */\n\tboolean compileInputSources();\n\n\t/**\n\t * Gets the classpath that is used to build/compile the input sources.\n\t *\n\t * @see #compileInputSources()\n\t * @see #build()\n\t * @see #compile()\n\t */\n\tString[] getSourceClasspath();\n\n\t/**\n\t * Sets the classpath that is used to build/compile the input sources.\n\t *\n\t * Each element of the array is either a jar file or a folder containing bytecode files.\n\t */\n\tvoid setSourceClasspath(String... classpath);\n\n\t/**\n\t * Gets the classpath that is used to build the template sources.\n\t *\n\t * See {@link #setSourceClasspath} for the meaning of the returned string.\n\t */\n\tString[] getTemplateClasspath();\n\n\t/**\n\t * Sets the classpath that is used to build the template sources.\n\t */\n\tvoid setTemplateClasspath(String... classpath);\n\n\t/**\n\t * Sets this compiler to optimize the model building process by ignoring\n\t * files that has not be modified since the latest source code generation.\n\t */\n\tvoid setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles);\n\n\t/**\n\t * When {@link #setBuildOnlyOutdatedFiles(boolean)} is true, adds a resource\n\t * to the forced-to-be-built list. All the files added here will be build\n\t * even if no changes are detected on the file system. This list has no\n\t * impacts if @link #setBuildOnlyOutdatedFiles(boolean)} is false.\n\t */\n\tvoid forceBuild(SpoonResource source);\n\n\t/**\n\t * Sets the encoding to use when different from the system encoding.\n\t */\n\tvoid setEncoding(String encoding);\n\n\t/**\n\t * Gets the encoding used by this compiler. Null means that it uses the\n\t * system encoding.\n\t */\n\tString getEncoding();\n\n\t/**\n\t * Returns the working factory\n\t */\n\tFactory getFactory();\n\n}",
        "location": {
          "path": "src/main/java/spoon/SpoonModelBuilder.java",
          "type": "Interface",
          "class": "spoon.SpoonModelBuilder"
        },
        "actions": [
          {
            "action": "Insert",
            "nodeType": "Method",
            "newLocation": {
              "endLine": 158,
              "sourceEnd": 4923,
              "line": 154,
              "sourceStart": 4757
            }
          },
          {
            "action": "Insert",
            "nodeType": "Annotation",
            "newLocation": {
              "endLine": 151,
              "sourceEnd": 4709,
              "line": 151,
              "sourceStart": 4699
            }
          }
        ]
      },
      {
        "oldFile": "package spoon.test.staticFieldAccess;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.util.Arrays;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\n\n\npublic class StaticAccessTest {\n\n    Launcher spoon;\n    Factory factory;\n    SpoonCompiler compiler;\n\n    @Before\n    public void setUp()  throws Exception {\n          spoon = new Launcher();\n          factory = spoon.createFactory();\n          compiler = spoon.createCompiler(\n                factory,\n                SpoonResourceHelper\n                        .resources(\n                                \"./src/test/java/spoon/test/staticFieldAccess/internal/\",\n                                \"./src/test/java/spoon/test/staticFieldAccess/StaticAccessBug.java\"\n                        ));\n        compiler.build();\n    }\n\n    @Test\n    public void testReferences() throws Exception {\n\n        CtType<?> type = (CtType<?>) factory.Type().get(\"spoon.test.staticFieldAccess.StaticAccessBug\");\n        CtBlock<?> block = type.getMethod(\"references\").getBody();\n        assertTrue(block.getStatement(0).toString().contains(\"Extends.MY_STATIC_VALUE\"));\n        assertTrue(block.getStatement(1).toString().contains(\"Extends.MY_OTHER_STATIC_VALUE\"));\n    }\n\n\n    @Test\n    public void testProcessAndCompile() throws Exception{\n        compiler.process(Arrays.asList(InsertBlockProcessor.class.getName()));\n\n        // generate files\n        File tmpdir = new File(\"target/spooned/staticFieldAccess\");\n        tmpdir.mkdirs();\n        //    tmpdir.deleteOnExit();\n        compiler.setSourceOutputDirectory(tmpdir);\n        compiler.generateProcessedSourceFiles(OutputType.COMPILATION_UNITS);\n\n        // try to reload generated datas\n        spoon = new Launcher();\n        compiler = spoon.createCompiler(\n                SpoonResourceHelper\n                        .resources(tmpdir.getAbsolutePath()));\n        assertTrue(compiler.build());\n    }\n\n}",
        "newFile": "package spoon.test.staticFieldAccess;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\n\nimport java.io.File;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertTrue;\n\n\npublic class StaticAccessTest {\n\n    Launcher spoon;\n    Factory factory;\n    SpoonCompiler compiler;\n\n    @Before\n    public void setUp()  throws Exception {\n          spoon = new Launcher();\n          factory = spoon.createFactory();\n          compiler = spoon.createCompiler(\n                factory,\n                SpoonResourceHelper\n                        .resources(\n                                \"./src/test/java/spoon/test/staticFieldAccess/internal/\",\n                                \"./src/test/java/spoon/test/staticFieldAccess/StaticAccessBug.java\"\n                        ));\n        compiler.build();\n    }\n\n    @Test\n    public void testReferences() throws Exception {\n\n        CtType<?> type = (CtType<?>) factory.Type().get(\"spoon.test.staticFieldAccess.StaticAccessBug\");\n        CtBlock<?> block = type.getMethod(\"references\").getBody();\n        assertTrue(block.getStatement(0).toString().contains(\"Extends.MY_STATIC_VALUE\"));\n        assertTrue(block.getStatement(1).toString().contains(\"Extends.MY_OTHER_STATIC_VALUE\"));\n    }\n\n\n    @Test\n    public void testProcessAndCompile() throws Exception{\n        compiler.instantiateAndProcess(Arrays.asList(InsertBlockProcessor.class.getName()));\n\n        // generate files\n        File tmpdir = new File(\"target/spooned/staticFieldAccess\");\n        tmpdir.mkdirs();\n        //    tmpdir.deleteOnExit();\n        compiler.setSourceOutputDirectory(tmpdir);\n        compiler.generateProcessedSourceFiles(OutputType.COMPILATION_UNITS);\n\n        // try to reload generated datas\n        spoon = new Launcher();\n        compiler = spoon.createCompiler(\n                SpoonResourceHelper\n                        .resources(tmpdir.getAbsolutePath()));\n        assertTrue(compiler.build());\n    }\n\n}",
        "location": {
          "path": "src/test/java/spoon/test/staticFieldAccess/StaticAccessTest.java",
          "type": "Test",
          "class": "spoon.test.staticFieldAccess.StaticAccessTest"
        }
      },
      {
        "oldFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\n\npackage spoon.support.compiler.jdt;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Level;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.IProblem;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.Main;\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.ModelBuildingException;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.QueueProcessingManager;\nimport spoon.support.compiler.FileSystemFile;\nimport spoon.support.compiler.VirtualFolder;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JDTBasedSpoonCompiler implements SpoonCompiler {\n\n\tpublic int javaCompliance = 7;\n\n\tprivate String[] templateClasspath = new String[0];\n\n\t/**\n\t * output directory for source code .java file\n\t */\n\tFile outputDirectory = new File(Launcher.OUTPUTDIR);\n\n\tboolean buildOnlyOutdatedFiles = false;\n\n\t@Override\n\tpublic void setSourceOutputDirectory(File outputDirectory) {\n\t\tthis.outputDirectory = outputDirectory;\n\t}\n\n\t@Override\n\tpublic File getSourceOutputDirectory() {\n\t\treturn outputDirectory;\n\t}\n\n\t/**\n\t * output directory for binary code .class file\n\t */\n\tFile binaryOutputDirectory;\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(File binaryOutputDirectory) {\n\t\tthis.binaryOutputDirectory = binaryOutputDirectory;\n\t}\n\n\t@Override\n\tpublic File getBinaryOutputDirectory() {\n\t\treturn binaryOutputDirectory;\n\t}\n\n\t/**\n\t * Default constructor\n\t */\n\tpublic JDTBasedSpoonCompiler(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t// example usage (please do not use directly, use instead the spoon.Launcher\n\t// API to create the factory)\n\tpublic static void main(String[] args) throws Exception {\n\t\tLauncher main = new Launcher();\n\t\tJDTBasedSpoonCompiler comp = new JDTBasedSpoonCompiler(main.createFactory());\n\t\tcomp.createBatchCompiler().printUsage();\n\t\tSpoonFile file = new FileSystemFile(new File(\"./src/main/java/spoon/support/compiler/JDTCompiler.java\"));\n\t\tcomp.addInputSource(file);\n\t\ttry {\n\t\t\tcomp.build();\n\t\t\tfinal Set<CtType<?>> types = comp.getFactory().Package().get(\"spoon.support.compiler\").getTypes();\n\t\t\tfor (CtType<?> type : types) {\n\t\t\t\tmain.getEnvironment().debugMessage(type.toString());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler(boolean useFactory) {\n\t\treturn new JDTBatchCompiler(this, useFactory);\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler() {\n\t\treturn createBatchCompiler(false);\n\t}\n\n\tprotected void keepOutdatedFiles(List<SpoonFile> files, Collection<File> outputFiles) {\n\t\t// System.out.println(\"outputfiles: \" + outputFiles);\n\n\t\tint offset = outputDirectory.getAbsolutePath().length() + 1;\n\t\tCollection<String> relativeOutputPaths = new ArrayList<String>();\n\t\tfor (File f : outputFiles) {\n\t\t\trelativeOutputPaths.add(f.getAbsolutePath().substring(offset));\n\t\t}\n\t\tfor (SpoonFile sf : new ArrayList<SpoonFile>(files)) {\n\t\t\tif (forceBuildList.contains(sf)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tFile f = sf.toFile();\n\t\t\tfor (String s : relativeOutputPaths) {\n\t\t\t\tif (f.getAbsolutePath().endsWith(s)) {\n\t\t\t\t\tif (f.lastModified() <= new File(outputDirectory, s).lastModified()) {\n\t\t\t\t\t\tfiles.remove(sf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"filtered: \" + files);\n\t}\n\n\tprotected boolean buildSources() {\n\t\tif (sources.getAllJavaFiles().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tinitInputClassLoader();\n\t\t// long t=System.currentTimeMillis();\n\t\t// Build input\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler();\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-d\");\n\t\t// args.add(\"none\");\n\n\t\tif (getSourceClasspath() != null) {\n\t\t\taddClasspathToJDTArgs(args);\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\targs.add(\"-cp\");\n\t\t\t\t\t\targs.add(classpath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// args.add(\"-nowarn\");\n\t\t// Set<String> paths = new HashSet<String>();\n\t\t// for (SpoonFile file : files) {\n\t\t// // We can not use file.getPath() because of in-memory code or files\n\t\t// // within archives\n\t\t// paths.add(file.getFileSystemParent().getPath());\n\t\t// }\n\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\n\t\tgetFactory().getEnvironment().debugMessage(\"build args: \" + args);\n\n\t\tbatchCompiler.configure(args.toArray(new String[0]));\n\n\t\tList<SpoonFile> filesToBuild = sources.getAllJavaFiles();\n\t\tif (buildOnlyOutdatedFiles) {\n\t\t\tif (outputDirectory.exists()) {\n\t\t\t\t@SuppressWarnings(\"unchecked\") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { \"java\" }, true);\n\t\t\t\tkeepOutdatedFiles(filesToBuild, outputFiles);\n\t\t\t} else {\n\t\t\t\tkeepOutdatedFiles(filesToBuild, new ArrayList<File>());\n\t\t\t}\n\t\t}\n\t\tCompilationUnitDeclaration[] units = batchCompiler.getUnits(filesToBuild);\n\n\t\t// here we build the model\n\t\tJDTTreeBuilder builder = new JDTTreeBuilder(factory);\n\t\tfor (CompilationUnitDeclaration unit : units) {\n\t\t\tunit.traverse(builder, unit.scope);\n\t\t}\n\n\t\treturn probs.size() == 0;\n\t}\n\n\tprivate Collection<? extends String> toStringList(List<SpoonFile> files) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tfor (SpoonFile f : files) {\n\t\t\tif (f.isActualFile()) {\n\t\t\t\tres.add(f.toString());\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFile file = File.createTempFile(f.getName(), \".java\");\n\t\t\t\t\tfile.deleteOnExit();\n\t\t\t\t\tIOUtils.copy(f.getContent(), new FileOutputStream(file));\n\n\t\t\t\t\tres.add(file.toString());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprotected String computeTemplateClasspath() {\n\t\treturn this.computeClasspath(this.getTemplateClasspath());\n\t}\n\n\tprotected String computeJdtClassPath() {\n\t\treturn this.computeClasspath(this.getSourceClasspath());\n\t}\n\n\tprivate String computeClasspath(String[] classpath) {\n\t\tif (classpath == null || classpath.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (String entry : classpath) {\n\t\t\tbuilder.append(entry);\n\t\t\tbuilder.append(File.pathSeparatorChar);\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\tprotected void addClasspathToJDTArgs(List<String> args) {\n\t\targs.add(\"-cp\");\n\t\targs.add(computeJdtClassPath());\n\t}\n\n\t// this function is used to hack the JDT compiler...\n\tprotected File createTmpJavaFile(File folder) {\n\t\tFile f = new File(folder, \"Tmp.java\");\n\t\tif (f.exists()) {\n\t\t\treturn f;\n\t\t}\n\t\ttry {\n\t\t\tFileUtils.writeStringToFile(f, \"class Tmp {}\");\n\t\t\tf.deleteOnExit();\n\t\t} catch (Exception e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn f;\n\t}\n\n\tprotected boolean buildTemplates() {\n\t\tif (templates.getAllJavaFiles().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler();\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-verbose\");\n\t\t// args.add(\"-d\");\n\t\t// args.add(\"none\");\n\t\t// args.add(\"-g\");\n\t\t// args.add(\"-nowarn\");\n\n\t\tFile f = null;\n\n\t\tif (this.templateClasspath != null && this.templateClasspath.length > 0) {\n\t\t\targs.add(\"-cp\");\n\t\t\targs.add(this.computeTemplateClasspath());\n\n\t\t\t// Set<String> paths = new HashSet<String>();\n\t\t\t// String sourcePaths = \"\";\n\t\t\t// for (SpoonFolder file : templates.getSubFolders()) {\n\t\t\t// if (file.isArchive()) {\n\t\t\t// sourcePaths += file.getPath() + File.pathSeparator;\n\t\t\t// }\n\t\t\t// }\n\t\t\t// for (SpoonFile file : files) {\n\t\t\t// if (!paths.contains(file.getFileSystemParent().getPath())) {\n\t\t\t// sourcePaths += file.getParent().getPath()\n\t\t\t// + File.pathSeparator;\n\t\t\t// }\n\t\t\t// paths.add(file.getPath());\n\t\t\t// }\n\t\t\t// args.add(\"-sourcepath\");\n\t\t\t// args.add(sourcePaths.substring(0, sourcePaths.length() - 1));\n\t\t\t// args.addAll(paths);\n\t\t\t// args.add(\".\");\n\t\t\tfor (SpoonFolder file : templates.getSubFolders()) {\n\t\t\t\tif (file.isArchive()) {\n\t\t\t\t\t// JDT bug HACK\n\t\t\t\t\tf = createTmpJavaFile(file.getFileSystemParent());\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.addAll(toStringList(templates.getAllJavaFiles()));\n\t\t} else {\n\t\t\t// when no class path is defined, we are probably in test and we try\n\t\t\t// to get as much source as we can compiled\n\t\t\targs.add(\".\");\n\t\t}\n\n\t\tgetFactory().getEnvironment().debugMessage(\"template build args: \" + args);\n\t\t// printUsage();\n\t\t// System.out.println(\"=>\" + args);\n\t\tbatchCompiler.configure(args.toArray(new String[0]));\n\t\tCompilationUnitDeclaration[] units = batchCompiler.getUnits(templates.getAllJavaFiles());\n\n\t\tif (f != null && f.exists()) {\n\t\t\tf.delete();\n\t\t}\n\n\t\t// here we build the model in the template factory\n\t\tJDTTreeBuilder builder = new JDTTreeBuilder(factory);\n\t\tfor (CompilationUnitDeclaration unit : units) {\n\t\t\tunit.traverse(builder, unit.scope);\n\t\t}\n\n\t\treturn probs.size() == 0;\n\n\t}\n\n\tINameEnvironment environment = null;\n\n\tpublic void setEnvironment(INameEnvironment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\tprivate final List<CategorizedProblem> probs = new ArrayList<CategorizedProblem>();\n\n\t/**\n\t * report a compilation problem (callback for JDT)\n\t */\n\tpublic void reportProblem(CategorizedProblem pb) {\n\t\tif (pb == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we can not accept this problem, even in noclasspath mode\n\t\t// otherwise a nasty null pointer exception occurs later\n\t\tif (pb.getID() == IProblem.DuplicateTypes) {\n\t\t\tthrow new ModelBuildingException(pb.getMessage());\n\t\t}\n\n\t\tprobs.add(pb);\n\t}\n\n\tpublic final TreeBuilderRequestor requestor = new TreeBuilderRequestor(this);\n\n\t/**\n\t * returns the list of current problems\n\t */\n\tpublic List<CategorizedProblem> getProblems() {\n\t\treturn Collections.unmodifiableList(this.probs);\n\t}\n\n\tprivate boolean build = false;\n\n\tSpoonFolder sources = new VirtualFolder();\n\n\tSpoonFolder templates = new VirtualFolder();\n\n\t@Override\n\tpublic void addInputSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddInputSource(r);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addTemplateSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddTemplateSource(r);\n\t\t}\n\t}\n\n\tpublic void addInputSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.sources.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.sources.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\tpublic void addInputSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.sources.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.sources.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\tpublic void addTemplateSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.templates.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.templates.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\tpublic void addTemplateSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.templates.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.templates.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\n\t}\n\n\tpublic boolean build() {\n\t\tif (factory == null) {\n\t\t\tthrow new SpoonException(\"Factory not initialized\");\n\t\t}\n\t\tif (build) {\n\t\t\tthrow new SpoonException(\"Model already built\");\n\t\t}\n\t\tbuild = true;\n\n\t\tboolean srcSuccess, templateSuccess;\n\t\tfactory.getEnvironment().debugMessage(\"building sources: \" + sources.getAllJavaFiles());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\t\tsrcSuccess = buildSources();\n\n\t\treportProblems(factory.getEnvironment());\n\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\tfactory.getEnvironment().debugMessage(\"building templates: \" + templates.getAllJavaFiles());\n\t\tt = System.currentTimeMillis();\n\t\ttemplateSuccess = buildTemplates();\n\t\t// factory.Template().parseTypes();\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn srcSuccess && templateSuccess;\n\t}\n\n\tprotected void report(Environment environment, CategorizedProblem problem) {\n\t\tif (problem == null) {\n\t\t\tthrow new IllegalArgumentException(\"problem cannot be null\");\n\t\t}\n\n\t\tFile file = new File(new String(problem.getOriginatingFileName()));\n\t\tString filename = file.getAbsolutePath();\n\n\t\tString message = problem.getMessage() + \" at \" + filename + \":\" + problem.getSourceLineNumber();\n\n\t\tif (problem.isError()) {\n\t\t\tif (!environment.getNoClasspath()) {\n\t\t\t\t// by default, compilation errors are notified as exception\n\t\t\t\tthrow new ModelBuildingException(message);\n\t\t\t} else {\n\t\t\t\t// in noclasspath mode, errors are only reported\n\t\t\t\tenvironment.report(null, problem.isError() ? Level.ERROR : Level.WARN, message);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void reportProblems(Environment environment) {\n\t\tif (getProblems().size() > 0) {\n\t\t\tfor (CategorizedProblem problem : getProblems()) {\n\t\t\t\tif (problem != null) {\n\t\t\t\t\treport(environment, problem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Set<File> getInputSources() {\n\t\tSet<File> files = new HashSet<File>();\n\t\tfor (SpoonFolder file : getSource().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\tpublic SpoonFolder getSource() {\n\t\treturn sources;\n\t}\n\n\tpublic SpoonFolder getTemplates() {\n\t\treturn templates;\n\t}\n\n\tpublic Set<File> getTemplateSources() {\n\t\tSet<File> files = new HashSet<File>();\n\t\tfor (SpoonFolder file : getTemplates().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic boolean compile() {\n\t\tinitInputClassLoader();\n\t\tfactory.getEnvironment().debugMessage(\"compiling sources: \" + factory.CompilationUnit().getMap().keySet());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler(true);\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-verbose\");\n\t\targs.add(\"-proc:none\");\n\t\tif (getBinaryOutputDirectory() != null) {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\t\t} else {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(\"none\");\n\t\t}\n\n\t\t// args.add(\"-d\");\n\t\t// args.add(getDestinationDirectory().toString());\n\n\t\tString finalClassPath = null;\n\t\tif (getSourceClasspath() != null) {\n\t\t\tfinalClassPath = computeJdtClassPath();\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\tfinalClassPath = classpath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\targs.add(\"-cp\");\n\t\targs.add(finalClassPath);\n\n\t\tif (buildOnlyOutdatedFiles) {\n\n\t\t\t// ignore the files that are not outdated\n\t\t\tif (outputDirectory.exists()) {\n\t\t\t\t@SuppressWarnings(\"unchecked\") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { \"java\" }, true);\n\t\t\t\tint offset = outputDirectory.getAbsolutePath().length() + 1;\n\t\t\t\tCollection<String> relativeOutputPaths = new ArrayList<String>();\n\t\t\t\tfor (File f : outputFiles) {\n\t\t\t\t\trelativeOutputPaths.add(f.getAbsolutePath().substring(offset));\n\t\t\t\t}\n\t\t\t\tfor (SpoonFile sf : sources.getAllJavaFiles()) {\n\t\t\t\t\tif (factory.CompilationUnit().getMap().containsKey(sf.getPath())) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tFile source = sf.toFile();\n\t\t\t\t\tfor (String out : relativeOutputPaths) {\n\t\t\t\t\t\tif (source.getAbsolutePath().endsWith(out)) {\n\t\t\t\t\t\t\tif (source.lastModified() <= new File(outputDirectory, out).lastModified()) {\n\t\t\t\t\t\t\t\tbatchCompiler.ignoreFile(new File(outputDirectory, out).getAbsolutePath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\n\t\t} else {\n\t\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\t\t}\n\n\t\tgetFactory().getEnvironment().debugMessage(\"compile args: \" + args);\n\n\t\t// batchCompiler.batchCompiler.useSingleThread = true;\n\n\t\tSystem.setProperty(\"jdt.compiler.useSingleThread\", \"true\");\n\n\t\tbatchCompiler.compile(args.toArray(new String[0]));\n\n\t\treportProblems(factory.getEnvironment());\n\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn probs.size() == 0;\n\n\t}\n\n\tFactory factory;\n\n\tMap<String, char[]> loadedContent = new HashMap<String, char[]>();\n\n\t@Override\n\tpublic void generateProcessedSourceFiles(OutputType outputType) {\n\t\tinitInputClassLoader();\n\t\tswitch (outputType) {\n\t\tcase CLASSES:\n\t\t\tgenerateProcessedSourceFilesUsingTypes();\n\t\t\tbreak;\n\n\t\tcase COMPILATION_UNITS:\n\t\t\tgenerateProcessedSourceFilesUsingCUs();\n\t\t\tbreak;\n\n\t\tcase NO_OUTPUT:\n\n\t\t}\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingTypes() {\n\t\tif (factory.getEnvironment().getDefaultFileGenerator() != null) {\n\t\t\tfactory.getEnvironment().debugMessage(\"Generating source using types...\");\n\t\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\t\tprocessing.addProcessor(factory.getEnvironment().getDefaultFileGenerator());\n\t\t\tprocessing.process(factory.Package().getRootPackage());\n\t\t}\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingCUs() {\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source using compilation units...\");\n\t\t// Check output directory\n\t\tif (outputDirectory == null) {\n\t\t\tthrow new RuntimeException(\"You should set output directory before generating source files\");\n\t\t}\n\t\t// Create spooned directory\n\t\tif (outputDirectory.isFile()) {\n\t\t\tthrow new RuntimeException(\"Output must be a directory\");\n\t\t}\n\t\tif (!outputDirectory.exists()) {\n\t\t\tif (!outputDirectory.mkdirs()) {\n\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\toutputDirectory = outputDirectory.getCanonicalFile();\n\t\t} catch (IOException e1) {\n\t\t\tthrow new SpoonException(e1);\n\t\t}\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source files to: \" + outputDirectory);\n\n\t\tList<File> printedFiles = new ArrayList<File>();\n\t\tfor (spoon.reflect.cu.CompilationUnit cu : factory.CompilationUnit().getMap().values()) {\n\n\t\t\tfactory.getEnvironment().debugMessage(\"Generating source for compilation unit: \" + cu.getFile());\n\n\t\t\tCtType<?> element = cu.getMainType();\n\n\t\t\tCtPackage pack = element.getPackage();\n\n\t\t\t// create package directory\n\t\t\tFile packageDir;\n\t\t\tif (pack.getQualifiedName().equals(CtPackage.TOP_LEVEL_PACKAGE_NAME)) {\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath());\n\t\t\t} else {\n\t\t\t\t// Create current package directory\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath() + File.separatorChar + pack.getQualifiedName().replace('.', File.separatorChar));\n\t\t\t}\n\t\t\tif (!packageDir.exists()) {\n\t\t\t\tif (!packageDir.mkdirs()) {\n\t\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print type\n\t\t\ttry {\n\t\t\t\tFile file = new File(packageDir.getAbsolutePath() + File.separatorChar + element.getSimpleName() + DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\t// the path must be given relatively to to the working directory\n\t\t\t\tInputStream is = getCompilationUnitInputStream(cu.getFile().getPath());\n\n\t\t\t\tIOUtils.copy(is, new FileOutputStream(file));\n\n\t\t\t\tif (!printedFiles.contains(file)) {\n\t\t\t\t\tprintedFiles.add(file);\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected InputStream getCompilationUnitInputStream(String path) {\n\t\tEnvironment env = factory.getEnvironment();\n\t\tspoon.reflect.cu.CompilationUnit cu = factory.CompilationUnit().getMap().get(path);\n\t\tList<CtType<?>> toBePrinted = cu.getDeclaredTypes();\n\n\t\tPrettyPrinter printer = null;\n\n\t\tif (printer == null) {\n\t\t\tprinter = new DefaultJavaPrettyPrinter(env);\n\t\t}\n\t\tprinter.calculate(cu, toBePrinted);\n\n\t\treturn new ByteArrayInputStream(printer.getResult().toString().getBytes());\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic boolean compileInputSources() {\n\t\tinitInputClassLoader();\n\t\tfactory.getEnvironment().debugMessage(\"compiling input sources: \" + sources.getAllJavaFiles());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\n\t\tMain batchCompiler = createBatchCompiler(false);\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\targs.add(\"-proc:none\");\n\t\tif (getBinaryOutputDirectory() != null) {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\t\t} else {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(\"none\");\n\t\t}\n\n\t\tString finalClassPath = null;\n\t\tif (getSourceClasspath() != null) {\n\t\t\tfinalClassPath = computeJdtClassPath();\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\tfinalClassPath = classpath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\targs.add(\"-cp\");\n\t\targs.add(finalClassPath);\n\n\t\t// Set<String> paths = new HashSet<String>();\n\t\t// for (SpoonFile file : sources.getAllJavaFiles()) {\n\t\t// paths.add(file.getParent().getPath());\n\t\t// }\n\t\t// args.addAll(paths);\n\n\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\n\t\t// configure(args.toArray(new String[0]));\n\n\t\tbatchCompiler.compile(args.toArray(new String[0]));\n\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn probs.size() == 0;\n\n\t}\n\n\t@Override\n\tpublic String[] getTemplateClasspath() {\n\t\treturn templateClasspath;\n\t}\n\n\t@Override\n\tpublic String[] getSourceClasspath() {\n\t\treturn getEnvironment().getSourceClasspath();\n\t}\n\n\t@Override\n\tpublic void setSourceClasspath(String... classpath) {\n\t\tgetEnvironment().setSourceClasspath(classpath);\n\t\t;\n\t}\n\n\t@Override\n\tpublic void setTemplateClasspath(String... classpath) {\n\t\tthis.templateClasspath = classpath;\n\t}\n\n\t@Override\n\tpublic void setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles) {\n\t\tthis.buildOnlyOutdatedFiles = buildOnlyOutdatedFiles;\n\t}\n\n\tList<SpoonResource> forceBuildList = new ArrayList<SpoonResource>();\n\n\t@Override\n\tpublic void forceBuild(SpoonResource source) {\n\t\tforceBuildList.add(source);\n\t}\n\n\tprotected String encoding;\n\n\t@Override\n\tpublic String getEncoding() {\n\t\treturn encoding;\n\t}\n\n\t@Override\n\tpublic void setEncoding(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n\n\tprivate CompilerClassLoader getCompilerClassLoader(ClassLoader initialClassLoader) {\n\t\twhile (initialClassLoader != null) {\n\t\t\tif (initialClassLoader instanceof CompilerClassLoader) {\n\t\t\t\treturn (CompilerClassLoader) initialClassLoader;\n\t\t\t}\n\t\t\tinitialClassLoader = initialClassLoader.getParent();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate boolean hasClassLoader(ClassLoader initialClassLoader, ClassLoader classLoader) {\n\t\twhile (initialClassLoader != null) {\n\t\t\tif (initialClassLoader == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tinitialClassLoader = initialClassLoader.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected void initInputClassLoader() {\n\t\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n\t\tif (buildOnlyOutdatedFiles && getBinaryOutputDirectory() != null) {\n\t\t\tCompilerClassLoader ccl = getCompilerClassLoader(cl);\n\t\t\tif (ccl == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLauncher.LOGGER.debug(\"setting classloader for \" + getBinaryOutputDirectory().toURI().toURL());\n\t\t\t\t\tThread.currentThread().setContextClassLoader(new CompilerClassLoader(new URL[] {\n\t\t\t\t\t\t\t\t\tgetBinaryOutputDirectory().toURI().toURL()\n\t\t\t\t\t\t\t}, factory.getEnvironment().getInputClassLoader()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!hasClassLoader(Thread.currentThread().getContextClassLoader(), factory.getEnvironment().getInputClassLoader())) {\n\t\t\t\tThread.currentThread().setContextClassLoader(factory.getEnvironment().getInputClassLoader());\n\t\t\t}\n\t\t}\n\t}\n\r\n\t@Override\r\n\tpublic void process(List<String> processorTypes) {\r\n\t\tinitInputClassLoader();\r\n\r\n\t\t// processing (consume all the processors)\r\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\r\n\t\tfor (String processorName : processorTypes) {\r\n\t\t\tprocessing.addProcessor(processorName);\r\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\r\n\t\t}\r\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\t@Override\n\tpublic void process(Collection<Processor<? extends CtElement>> processors) {\n\t\tinitInputClassLoader();\n\n\t\t// processing (consume all the processors)\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\tfor (Processor<? extends CtElement> processorName : processors) {\n\t\t\tprocessing.addProcessor(processorName);\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\n\t\t}\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\tprotected Environment getEnvironment() {\n\t\treturn getFactory().getEnvironment();\n\t}\n}",
        "newFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\n\npackage spoon.support.compiler.jdt;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Level;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.IProblem;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.Main;\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.ModelBuildingException;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.QueueProcessingManager;\nimport spoon.support.compiler.FileSystemFile;\nimport spoon.support.compiler.VirtualFolder;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JDTBasedSpoonCompiler implements SpoonCompiler {\n\n\tpublic int javaCompliance = 7;\n\n\tprivate String[] templateClasspath = new String[0];\n\n\t/**\n\t * output directory for source code .java file\n\t */\n\tFile outputDirectory = new File(Launcher.OUTPUTDIR);\n\n\tboolean buildOnlyOutdatedFiles = false;\n\n\t@Override\n\tpublic void setSourceOutputDirectory(File outputDirectory) {\n\t\tthis.outputDirectory = outputDirectory;\n\t}\n\n\t@Override\n\tpublic File getSourceOutputDirectory() {\n\t\treturn outputDirectory;\n\t}\n\n\t/**\n\t * output directory for binary code .class file\n\t */\n\tFile binaryOutputDirectory;\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(File binaryOutputDirectory) {\n\t\tthis.binaryOutputDirectory = binaryOutputDirectory;\n\t}\n\n\t@Override\n\tpublic File getBinaryOutputDirectory() {\n\t\treturn binaryOutputDirectory;\n\t}\n\n\t/**\n\t * Default constructor\n\t */\n\tpublic JDTBasedSpoonCompiler(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t// example usage (please do not use directly, use instead the spoon.Launcher\n\t// API to create the factory)\n\tpublic static void main(String[] args) throws Exception {\n\t\tLauncher main = new Launcher();\n\t\tJDTBasedSpoonCompiler comp = new JDTBasedSpoonCompiler(main.createFactory());\n\t\tcomp.createBatchCompiler().printUsage();\n\t\tSpoonFile file = new FileSystemFile(new File(\"./src/main/java/spoon/support/compiler/JDTCompiler.java\"));\n\t\tcomp.addInputSource(file);\n\t\ttry {\n\t\t\tcomp.build();\n\t\t\tfinal Set<CtType<?>> types = comp.getFactory().Package().get(\"spoon.support.compiler\").getTypes();\n\t\t\tfor (CtType<?> type : types) {\n\t\t\t\tmain.getEnvironment().debugMessage(type.toString());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler(boolean useFactory) {\n\t\treturn new JDTBatchCompiler(this, useFactory);\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler() {\n\t\treturn createBatchCompiler(false);\n\t}\n\n\tprotected void keepOutdatedFiles(List<SpoonFile> files, Collection<File> outputFiles) {\n\t\t// System.out.println(\"outputfiles: \" + outputFiles);\n\n\t\tint offset = outputDirectory.getAbsolutePath().length() + 1;\n\t\tCollection<String> relativeOutputPaths = new ArrayList<String>();\n\t\tfor (File f : outputFiles) {\n\t\t\trelativeOutputPaths.add(f.getAbsolutePath().substring(offset));\n\t\t}\n\t\tfor (SpoonFile sf : new ArrayList<SpoonFile>(files)) {\n\t\t\tif (forceBuildList.contains(sf)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tFile f = sf.toFile();\n\t\t\tfor (String s : relativeOutputPaths) {\n\t\t\t\tif (f.getAbsolutePath().endsWith(s)) {\n\t\t\t\t\tif (f.lastModified() <= new File(outputDirectory, s).lastModified()) {\n\t\t\t\t\t\tfiles.remove(sf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"filtered: \" + files);\n\t}\n\n\tprotected boolean buildSources() {\n\t\tif (sources.getAllJavaFiles().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tinitInputClassLoader();\n\t\t// long t=System.currentTimeMillis();\n\t\t// Build input\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler();\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-d\");\n\t\t// args.add(\"none\");\n\n\t\tif (getSourceClasspath() != null) {\n\t\t\taddClasspathToJDTArgs(args);\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\targs.add(\"-cp\");\n\t\t\t\t\t\targs.add(classpath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// args.add(\"-nowarn\");\n\t\t// Set<String> paths = new HashSet<String>();\n\t\t// for (SpoonFile file : files) {\n\t\t// // We can not use file.getPath() because of in-memory code or files\n\t\t// // within archives\n\t\t// paths.add(file.getFileSystemParent().getPath());\n\t\t// }\n\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\n\t\tgetFactory().getEnvironment().debugMessage(\"build args: \" + args);\n\n\t\tbatchCompiler.configure(args.toArray(new String[0]));\n\n\t\tList<SpoonFile> filesToBuild = sources.getAllJavaFiles();\n\t\tif (buildOnlyOutdatedFiles) {\n\t\t\tif (outputDirectory.exists()) {\n\t\t\t\t@SuppressWarnings(\"unchecked\") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { \"java\" }, true);\n\t\t\t\tkeepOutdatedFiles(filesToBuild, outputFiles);\n\t\t\t} else {\n\t\t\t\tkeepOutdatedFiles(filesToBuild, new ArrayList<File>());\n\t\t\t}\n\t\t}\n\t\tCompilationUnitDeclaration[] units = batchCompiler.getUnits(filesToBuild);\n\n\t\t// here we build the model\n\t\tJDTTreeBuilder builder = new JDTTreeBuilder(factory);\n\t\tfor (CompilationUnitDeclaration unit : units) {\n\t\t\tunit.traverse(builder, unit.scope);\n\t\t}\n\n\t\treturn probs.size() == 0;\n\t}\n\n\tprivate Collection<? extends String> toStringList(List<SpoonFile> files) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tfor (SpoonFile f : files) {\n\t\t\tif (f.isActualFile()) {\n\t\t\t\tres.add(f.toString());\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFile file = File.createTempFile(f.getName(), \".java\");\n\t\t\t\t\tfile.deleteOnExit();\n\t\t\t\t\tIOUtils.copy(f.getContent(), new FileOutputStream(file));\n\n\t\t\t\t\tres.add(file.toString());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprotected String computeTemplateClasspath() {\n\t\treturn this.computeClasspath(this.getTemplateClasspath());\n\t}\n\n\tprotected String computeJdtClassPath() {\n\t\treturn this.computeClasspath(this.getSourceClasspath());\n\t}\n\n\tprivate String computeClasspath(String[] classpath) {\n\t\tif (classpath == null || classpath.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (String entry : classpath) {\n\t\t\tbuilder.append(entry);\n\t\t\tbuilder.append(File.pathSeparatorChar);\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\tprotected void addClasspathToJDTArgs(List<String> args) {\n\t\targs.add(\"-cp\");\n\t\targs.add(computeJdtClassPath());\n\t}\n\n\t// this function is used to hack the JDT compiler...\n\tprotected File createTmpJavaFile(File folder) {\n\t\tFile f = new File(folder, \"Tmp.java\");\n\t\tif (f.exists()) {\n\t\t\treturn f;\n\t\t}\n\t\ttry {\n\t\t\tFileUtils.writeStringToFile(f, \"class Tmp {}\");\n\t\t\tf.deleteOnExit();\n\t\t} catch (Exception e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn f;\n\t}\n\n\tprotected boolean buildTemplates() {\n\t\tif (templates.getAllJavaFiles().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler();\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-verbose\");\n\t\t// args.add(\"-d\");\n\t\t// args.add(\"none\");\n\t\t// args.add(\"-g\");\n\t\t// args.add(\"-nowarn\");\n\n\t\tFile f = null;\n\n\t\tif (this.templateClasspath != null && this.templateClasspath.length > 0) {\n\t\t\targs.add(\"-cp\");\n\t\t\targs.add(this.computeTemplateClasspath());\n\n\t\t\t// Set<String> paths = new HashSet<String>();\n\t\t\t// String sourcePaths = \"\";\n\t\t\t// for (SpoonFolder file : templates.getSubFolders()) {\n\t\t\t// if (file.isArchive()) {\n\t\t\t// sourcePaths += file.getPath() + File.pathSeparator;\n\t\t\t// }\n\t\t\t// }\n\t\t\t// for (SpoonFile file : files) {\n\t\t\t// if (!paths.contains(file.getFileSystemParent().getPath())) {\n\t\t\t// sourcePaths += file.getParent().getPath()\n\t\t\t// + File.pathSeparator;\n\t\t\t// }\n\t\t\t// paths.add(file.getPath());\n\t\t\t// }\n\t\t\t// args.add(\"-sourcepath\");\n\t\t\t// args.add(sourcePaths.substring(0, sourcePaths.length() - 1));\n\t\t\t// args.addAll(paths);\n\t\t\t// args.add(\".\");\n\t\t\tfor (SpoonFolder file : templates.getSubFolders()) {\n\t\t\t\tif (file.isArchive()) {\n\t\t\t\t\t// JDT bug HACK\n\t\t\t\t\tf = createTmpJavaFile(file.getFileSystemParent());\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.addAll(toStringList(templates.getAllJavaFiles()));\n\t\t} else {\n\t\t\t// when no class path is defined, we are probably in test and we try\n\t\t\t// to get as much source as we can compiled\n\t\t\targs.add(\".\");\n\t\t}\n\n\t\tgetFactory().getEnvironment().debugMessage(\"template build args: \" + args);\n\t\t// printUsage();\n\t\t// System.out.println(\"=>\" + args);\n\t\tbatchCompiler.configure(args.toArray(new String[0]));\n\t\tCompilationUnitDeclaration[] units = batchCompiler.getUnits(templates.getAllJavaFiles());\n\n\t\tif (f != null && f.exists()) {\n\t\t\tf.delete();\n\t\t}\n\n\t\t// here we build the model in the template factory\n\t\tJDTTreeBuilder builder = new JDTTreeBuilder(factory);\n\t\tfor (CompilationUnitDeclaration unit : units) {\n\t\t\tunit.traverse(builder, unit.scope);\n\t\t}\n\n\t\treturn probs.size() == 0;\n\n\t}\n\n\tINameEnvironment environment = null;\n\n\tpublic void setEnvironment(INameEnvironment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\tprivate final List<CategorizedProblem> probs = new ArrayList<CategorizedProblem>();\n\n\t/**\n\t * report a compilation problem (callback for JDT)\n\t */\n\tpublic void reportProblem(CategorizedProblem pb) {\n\t\tif (pb == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we can not accept this problem, even in noclasspath mode\n\t\t// otherwise a nasty null pointer exception occurs later\n\t\tif (pb.getID() == IProblem.DuplicateTypes) {\n\t\t\tthrow new ModelBuildingException(pb.getMessage());\n\t\t}\n\n\t\tprobs.add(pb);\n\t}\n\n\tpublic final TreeBuilderRequestor requestor = new TreeBuilderRequestor(this);\n\n\t/**\n\t * returns the list of current problems\n\t */\n\tpublic List<CategorizedProblem> getProblems() {\n\t\treturn Collections.unmodifiableList(this.probs);\n\t}\n\n\tprivate boolean build = false;\n\n\tSpoonFolder sources = new VirtualFolder();\n\n\tSpoonFolder templates = new VirtualFolder();\n\n\t@Override\n\tpublic void addInputSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddInputSource(r);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addTemplateSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddTemplateSource(r);\n\t\t}\n\t}\n\n\tpublic void addInputSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.sources.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.sources.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\tpublic void addInputSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.sources.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.sources.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\tpublic void addTemplateSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.templates.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.templates.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\tpublic void addTemplateSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.templates.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.templates.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\n\t}\n\n\tpublic boolean build() {\n\t\tif (factory == null) {\n\t\t\tthrow new SpoonException(\"Factory not initialized\");\n\t\t}\n\t\tif (build) {\n\t\t\tthrow new SpoonException(\"Model already built\");\n\t\t}\n\t\tbuild = true;\n\n\t\tboolean srcSuccess, templateSuccess;\n\t\tfactory.getEnvironment().debugMessage(\"building sources: \" + sources.getAllJavaFiles());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\t\tsrcSuccess = buildSources();\n\n\t\treportProblems(factory.getEnvironment());\n\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\tfactory.getEnvironment().debugMessage(\"building templates: \" + templates.getAllJavaFiles());\n\t\tt = System.currentTimeMillis();\n\t\ttemplateSuccess = buildTemplates();\n\t\t// factory.Template().parseTypes();\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn srcSuccess && templateSuccess;\n\t}\n\n\tprotected void report(Environment environment, CategorizedProblem problem) {\n\t\tif (problem == null) {\n\t\t\tthrow new IllegalArgumentException(\"problem cannot be null\");\n\t\t}\n\n\t\tFile file = new File(new String(problem.getOriginatingFileName()));\n\t\tString filename = file.getAbsolutePath();\n\n\t\tString message = problem.getMessage() + \" at \" + filename + \":\" + problem.getSourceLineNumber();\n\n\t\tif (problem.isError()) {\n\t\t\tif (!environment.getNoClasspath()) {\n\t\t\t\t// by default, compilation errors are notified as exception\n\t\t\t\tthrow new ModelBuildingException(message);\n\t\t\t} else {\n\t\t\t\t// in noclasspath mode, errors are only reported\n\t\t\t\tenvironment.report(null, problem.isError() ? Level.ERROR : Level.WARN, message);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void reportProblems(Environment environment) {\n\t\tif (getProblems().size() > 0) {\n\t\t\tfor (CategorizedProblem problem : getProblems()) {\n\t\t\t\tif (problem != null) {\n\t\t\t\t\treport(environment, problem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Set<File> getInputSources() {\n\t\tSet<File> files = new HashSet<File>();\n\t\tfor (SpoonFolder file : getSource().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\tpublic SpoonFolder getSource() {\n\t\treturn sources;\n\t}\n\n\tpublic SpoonFolder getTemplates() {\n\t\treturn templates;\n\t}\n\n\tpublic Set<File> getTemplateSources() {\n\t\tSet<File> files = new HashSet<File>();\n\t\tfor (SpoonFolder file : getTemplates().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic boolean compile() {\n\t\tinitInputClassLoader();\n\t\tfactory.getEnvironment().debugMessage(\"compiling sources: \" + factory.CompilationUnit().getMap().keySet());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler(true);\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\t// args.add(\"-verbose\");\n\t\targs.add(\"-proc:none\");\n\t\tif (getBinaryOutputDirectory() != null) {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\t\t} else {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(\"none\");\n\t\t}\n\n\t\t// args.add(\"-d\");\n\t\t// args.add(getDestinationDirectory().toString());\n\n\t\tString finalClassPath = null;\n\t\tif (getSourceClasspath() != null) {\n\t\t\tfinalClassPath = computeJdtClassPath();\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\tfinalClassPath = classpath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\targs.add(\"-cp\");\n\t\targs.add(finalClassPath);\n\n\t\tif (buildOnlyOutdatedFiles) {\n\n\t\t\t// ignore the files that are not outdated\n\t\t\tif (outputDirectory.exists()) {\n\t\t\t\t@SuppressWarnings(\"unchecked\") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { \"java\" }, true);\n\t\t\t\tint offset = outputDirectory.getAbsolutePath().length() + 1;\n\t\t\t\tCollection<String> relativeOutputPaths = new ArrayList<String>();\n\t\t\t\tfor (File f : outputFiles) {\n\t\t\t\t\trelativeOutputPaths.add(f.getAbsolutePath().substring(offset));\n\t\t\t\t}\n\t\t\t\tfor (SpoonFile sf : sources.getAllJavaFiles()) {\n\t\t\t\t\tif (factory.CompilationUnit().getMap().containsKey(sf.getPath())) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tFile source = sf.toFile();\n\t\t\t\t\tfor (String out : relativeOutputPaths) {\n\t\t\t\t\t\tif (source.getAbsolutePath().endsWith(out)) {\n\t\t\t\t\t\t\tif (source.lastModified() <= new File(outputDirectory, out).lastModified()) {\n\t\t\t\t\t\t\t\tbatchCompiler.ignoreFile(new File(outputDirectory, out).getAbsolutePath());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\n\t\t} else {\n\t\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\t\t}\n\n\t\tgetFactory().getEnvironment().debugMessage(\"compile args: \" + args);\n\n\t\t// batchCompiler.batchCompiler.useSingleThread = true;\n\n\t\tSystem.setProperty(\"jdt.compiler.useSingleThread\", \"true\");\n\n\t\tbatchCompiler.compile(args.toArray(new String[0]));\n\n\t\treportProblems(factory.getEnvironment());\n\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn probs.size() == 0;\n\n\t}\n\n\tFactory factory;\n\n\tMap<String, char[]> loadedContent = new HashMap<String, char[]>();\n\n\t@Override\n\tpublic void generateProcessedSourceFiles(OutputType outputType) {\n\t\tinitInputClassLoader();\n\t\tswitch (outputType) {\n\t\tcase CLASSES:\n\t\t\tgenerateProcessedSourceFilesUsingTypes();\n\t\t\tbreak;\n\n\t\tcase COMPILATION_UNITS:\n\t\t\tgenerateProcessedSourceFilesUsingCUs();\n\t\t\tbreak;\n\n\t\tcase NO_OUTPUT:\n\n\t\t}\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingTypes() {\n\t\tif (factory.getEnvironment().getDefaultFileGenerator() != null) {\n\t\t\tfactory.getEnvironment().debugMessage(\"Generating source using types...\");\n\t\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\t\tprocessing.addProcessor(factory.getEnvironment().getDefaultFileGenerator());\n\t\t\tprocessing.process(factory.Package().getRootPackage());\n\t\t}\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingCUs() {\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source using compilation units...\");\n\t\t// Check output directory\n\t\tif (outputDirectory == null) {\n\t\t\tthrow new RuntimeException(\"You should set output directory before generating source files\");\n\t\t}\n\t\t// Create spooned directory\n\t\tif (outputDirectory.isFile()) {\n\t\t\tthrow new RuntimeException(\"Output must be a directory\");\n\t\t}\n\t\tif (!outputDirectory.exists()) {\n\t\t\tif (!outputDirectory.mkdirs()) {\n\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\toutputDirectory = outputDirectory.getCanonicalFile();\n\t\t} catch (IOException e1) {\n\t\t\tthrow new SpoonException(e1);\n\t\t}\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source files to: \" + outputDirectory);\n\n\t\tList<File> printedFiles = new ArrayList<File>();\n\t\tfor (spoon.reflect.cu.CompilationUnit cu : factory.CompilationUnit().getMap().values()) {\n\n\t\t\tfactory.getEnvironment().debugMessage(\"Generating source for compilation unit: \" + cu.getFile());\n\n\t\t\tCtType<?> element = cu.getMainType();\n\n\t\t\tCtPackage pack = element.getPackage();\n\n\t\t\t// create package directory\n\t\t\tFile packageDir;\n\t\t\tif (pack.getQualifiedName().equals(CtPackage.TOP_LEVEL_PACKAGE_NAME)) {\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath());\n\t\t\t} else {\n\t\t\t\t// Create current package directory\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath() + File.separatorChar + pack.getQualifiedName().replace('.', File.separatorChar));\n\t\t\t}\n\t\t\tif (!packageDir.exists()) {\n\t\t\t\tif (!packageDir.mkdirs()) {\n\t\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print type\n\t\t\ttry {\n\t\t\t\tFile file = new File(packageDir.getAbsolutePath() + File.separatorChar + element.getSimpleName() + DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\t// the path must be given relatively to to the working directory\n\t\t\t\tInputStream is = getCompilationUnitInputStream(cu.getFile().getPath());\n\n\t\t\t\tIOUtils.copy(is, new FileOutputStream(file));\n\n\t\t\t\tif (!printedFiles.contains(file)) {\n\t\t\t\t\tprintedFiles.add(file);\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected InputStream getCompilationUnitInputStream(String path) {\n\t\tEnvironment env = factory.getEnvironment();\n\t\tspoon.reflect.cu.CompilationUnit cu = factory.CompilationUnit().getMap().get(path);\n\t\tList<CtType<?>> toBePrinted = cu.getDeclaredTypes();\n\n\t\tPrettyPrinter printer = null;\n\n\t\tif (printer == null) {\n\t\t\tprinter = new DefaultJavaPrettyPrinter(env);\n\t\t}\n\t\tprinter.calculate(cu, toBePrinted);\n\n\t\treturn new ByteArrayInputStream(printer.getResult().toString().getBytes());\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic boolean compileInputSources() {\n\t\tinitInputClassLoader();\n\t\tfactory.getEnvironment().debugMessage(\"compiling input sources: \" + sources.getAllJavaFiles());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\n\t\tMain batchCompiler = createBatchCompiler(false);\n\t\tList<String> args = new ArrayList<String>();\n\t\targs.add(\"-1.\" + javaCompliance);\n\t\tif (encoding != null) {\n\t\t\targs.add(\"-encoding\");\n\t\t\targs.add(encoding);\n\t\t}\n\t\targs.add(\"-preserveAllLocals\");\n\t\targs.add(\"-enableJavadoc\");\n\t\targs.add(\"-noExit\");\n\t\targs.add(\"-proc:none\");\n\t\tif (getBinaryOutputDirectory() != null) {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(getBinaryOutputDirectory().getAbsolutePath());\n\t\t} else {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(\"none\");\n\t\t}\n\n\t\tString finalClassPath = null;\n\t\tif (getSourceClasspath() != null) {\n\t\t\tfinalClassPath = computeJdtClassPath();\n\t\t} else {\n\t\t\tClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\t\t\tif (currentClassLoader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) currentClassLoader).getURLs();\n\t\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t\tString classpath = \".\";\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath += File.pathSeparator + url.getFile();\n\t\t\t\t\t}\n\t\t\t\t\tif (classpath != null) {\n\t\t\t\t\t\tfinalClassPath = classpath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\targs.add(\"-cp\");\n\t\targs.add(finalClassPath);\n\n\t\t// Set<String> paths = new HashSet<String>();\n\t\t// for (SpoonFile file : sources.getAllJavaFiles()) {\n\t\t// paths.add(file.getParent().getPath());\n\t\t// }\n\t\t// args.addAll(paths);\n\n\t\targs.addAll(toStringList(sources.getAllJavaFiles()));\n\n\t\t// configure(args.toArray(new String[0]));\n\n\t\tbatchCompiler.compile(args.toArray(new String[0]));\n\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn probs.size() == 0;\n\n\t}\n\n\t@Override\n\tpublic String[] getTemplateClasspath() {\n\t\treturn templateClasspath;\n\t}\n\n\t@Override\n\tpublic String[] getSourceClasspath() {\n\t\treturn getEnvironment().getSourceClasspath();\n\t}\n\n\t@Override\n\tpublic void setSourceClasspath(String... classpath) {\n\t\tgetEnvironment().setSourceClasspath(classpath);\n\t\t;\n\t}\n\n\t@Override\n\tpublic void setTemplateClasspath(String... classpath) {\n\t\tthis.templateClasspath = classpath;\n\t}\n\n\t@Override\n\tpublic void setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles) {\n\t\tthis.buildOnlyOutdatedFiles = buildOnlyOutdatedFiles;\n\t}\n\n\tList<SpoonResource> forceBuildList = new ArrayList<SpoonResource>();\n\n\t@Override\n\tpublic void forceBuild(SpoonResource source) {\n\t\tforceBuildList.add(source);\n\t}\n\n\tprotected String encoding;\n\n\t@Override\n\tpublic String getEncoding() {\n\t\treturn encoding;\n\t}\n\n\t@Override\n\tpublic void setEncoding(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n\n\tprivate CompilerClassLoader getCompilerClassLoader(ClassLoader initialClassLoader) {\n\t\twhile (initialClassLoader != null) {\n\t\t\tif (initialClassLoader instanceof CompilerClassLoader) {\n\t\t\t\treturn (CompilerClassLoader) initialClassLoader;\n\t\t\t}\n\t\t\tinitialClassLoader = initialClassLoader.getParent();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate boolean hasClassLoader(ClassLoader initialClassLoader, ClassLoader classLoader) {\n\t\twhile (initialClassLoader != null) {\n\t\t\tif (initialClassLoader == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tinitialClassLoader = initialClassLoader.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected void initInputClassLoader() {\n\t\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n\t\tif (buildOnlyOutdatedFiles && getBinaryOutputDirectory() != null) {\n\t\t\tCompilerClassLoader ccl = getCompilerClassLoader(cl);\n\t\t\tif (ccl == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLauncher.LOGGER.debug(\"setting classloader for \" + getBinaryOutputDirectory().toURI().toURL());\n\t\t\t\t\tThread.currentThread().setContextClassLoader(new CompilerClassLoader(new URL[] {\n\t\t\t\t\t\t\t\t\tgetBinaryOutputDirectory().toURI().toURL()\n\t\t\t\t\t\t\t}, factory.getEnvironment().getInputClassLoader()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!hasClassLoader(Thread.currentThread().getContextClassLoader(), factory.getEnvironment().getInputClassLoader())) {\n\t\t\t\tThread.currentThread().setContextClassLoader(factory.getEnvironment().getInputClassLoader());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void process(List<String> processorTypes) {\n\t\tinstantiateAndProcess(processorTypes);\n\t}\n\n\t@Override\n\tpublic void instantiateAndProcess(List<String> processors) {\n\t\tinitInputClassLoader();\n\n\t\t// processing (consume all the processors)\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\tfor (String processorName : processors) {\n\t\t\tprocessing.addProcessor(processorName);\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\n\t\t}\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\t@Override\n\tpublic void process(Collection<Processor<? extends CtElement>> processors) {\n\t\tinitInputClassLoader();\n\n\t\t// processing (consume all the processors)\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\tfor (Processor<? extends CtElement> processorName : processors) {\n\t\t\tprocessing.addProcessor(processorName);\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\n\t\t}\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\tprotected Environment getEnvironment() {\n\t\treturn getFactory().getEnvironment();\n\t}\n}",
        "location": {
          "path": "src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java",
          "type": "Class",
          "class": "spoon.support.compiler.jdt.JDTBasedSpoonCompiler"
        },
        "actions": [
          {
            "oldLocation": {
              "endLine": 922,
              "sourceEnd": 27076,
              "line": 922,
              "sourceStart": 27063
            },
            "action": "Update",
            "nodeType": "VariableRead",
            "newLocation": {
              "endLine": 927,
              "sourceEnd": 27183,
              "line": 927,
              "sourceStart": 27174
            }
          },
          {
            "oldLocation": {
              "endLine": 917,
              "sourceEnd": 26881,
              "line": 917,
              "sourceStart": 26855
            },
            "action": "Update",
            "nodeType": "Parameter",
            "newLocation": {
              "endLine": 922,
              "sourceEnd": 26997,
              "line": 922,
              "sourceStart": 26975
            }
          },
          {
            "oldLocation": {
              "endLine": 928,
              "sourceEnd": 27277,
              "line": 916,
              "sourceStart": 26823
            },
            "action": "Update",
            "nodeType": "Method",
            "newLocation": {
              "endLine": 933,
              "sourceEnd": 27380,
              "line": 921,
              "sourceStart": 26930
            }
          },
          {
            "action": "Insert",
            "nodeType": "Method",
            "newLocation": {
              "endLine": 919,
              "sourceEnd": 26926,
              "line": 916,
              "sourceStart": 26822
            }
          },
          {
            "oldLocation": {
              "endLine": 928,
              "sourceEnd": 27277,
              "line": 916,
              "sourceStart": 26823
            },
            "action": "Move",
            "nodeType": "Method",
            "newLocation": {
              "endLine": 933,
              "sourceEnd": 27380,
              "line": 921,
              "sourceStart": 26930
            }
          }
        ]
      },
      {
        "oldFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\npackage spoon;\n\nimport com.martiansoftware.jsap.FlaggedOption;\nimport com.martiansoftware.jsap.JSAP;\nimport com.martiansoftware.jsap.JSAPException;\nimport com.martiansoftware.jsap.JSAPResult;\nimport com.martiansoftware.jsap.Switch;\nimport com.martiansoftware.jsap.stringparsers.FileStringParser;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.JavaOutputProcessor;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.compiler.FileSystemFile;\nimport spoon.support.compiler.FileSystemFolder;\nimport spoon.support.compiler.jdt.JDTBasedSpoonCompiler;\nimport spoon.support.gui.SpoonModelTree;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.ResourceBundle;\n\n/**\n * This class implements an integrated command-line launcher for processing\n * programs at compile-time using the JDT-based builder (Eclipse). It takes\n * arguments that allow building, processing, printing, and compiling Java\n * programs. Launch with no arguments (see {@link #main(String[])}) for detailed\n * usage.\n */\npublic class Launcher implements SpoonAPI {\n\n\tpublic static final String OUTPUTDIR = \"spooned\";\n\n\tprivate Factory factory = createFactory();\n\n\tprivate SpoonCompiler modelBuilder;\n\n\tprivate String[] commandLineArgs = new String[0];\n\n\t/**\n\t * Contains the arguments accepted by this launcher (available after\n\t * construction and accessible by sub-classes).\n\t */\n\tprivate static JSAP jsapSpec;\n\tprotected JSAPResult jsapActualArgs;\n\n\tprivate List<String> processorTypes = new ArrayList<String>();\n\tprivate List<Processor<? extends CtElement>> processors = new ArrayList<Processor<? extends CtElement>>();\n\n\t/**\n\t * A default program entry point (instantiates a launcher with the given\n\t * arguments and calls {@link #run()}).\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Launcher().run(args);\n\t}\n\n\t@Override\n\tpublic void run(String[] args) {\n\t\tthis.setArgs(args);\n\t\tif (args.length != 0) {\n\t\t\tthis.run();\n\t\t\t// display GUI\n\t\t\tif (this.jsapActualArgs.getBoolean(\"gui\")) {\n\t\t\t\tnew SpoonModelTree(getFactory());\n\t\t\t}\n\t\t} else {\n\t\t\tthis.printUsage();\n\t\t}\n\t}\n\n\tpublic void setArgs(String[] args2) {\n\t\tthis.commandLineArgs = args2;\n\t\tprocessArguments();\n\t}\n\n\tpublic void printUsage() {\n\t\tthis.commandLineArgs = new String[] { \"--help\" };\n\t\tprocessArguments();\n\t}\n\n\tstatic {\n\t\tjsapSpec = defineArgs();\n\t}\n\n\t/**\n\t * Constructor with no arguments.\n\t */\n\tpublic Launcher() {\n\t\tprocessArguments();\n\t}\n\n\t@Override\n\tpublic void addInputResource(String path) {\n\t\tFile file = new File(path);\n\t\tif (file.isDirectory()) {\n\t\t\taddInputResource(new FileSystemFolder(file));\n\t\t} else {\n\t\t\taddInputResource(new FileSystemFile(file));\n\t\t}\n\t}\n\n\tprivate void addInputResource(SpoonResource resource) {\n\t\tmodelBuilder.addInputSource(resource);\n\t}\n\n\t@Override\n\tpublic void addProcessor(String name) {\n\t\tprocessorTypes.add(name);\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> void addProcessor(Processor<T> processor) {\n\t\tprocessors.add(processor);\n\t}\n\n\tpublic void addTemplateResource(SpoonResource resource) {\n\t\tmodelBuilder.addTemplateSource(resource);\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn factory.getEnvironment();\n\t}\n\n\t/**\n\t * Defines the common arguments for sub-launchers.\n\t *\n\t * @return the JSAP arguments\n\t */\n\tprotected static JSAP defineArgs() {\n\t\ttry {\n\t\t\t// Verbose output\n\t\t\tJSAP jsap = new JSAP();\n\n\t\t\t// help\n\t\t\tSwitch sw1 = new Switch(\"help\");\n\t\t\tsw1.setShortFlag('h');\n\t\t\tsw1.setLongFlag(\"help\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Tabs\n\t\t\tsw1 = new Switch(\"tabs\");\n\t\t\tsw1.setLongFlag(\"tabs\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tsw1.setHelp(\"Use tabulations instead of spaces in the generated code (use spaces by default).\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Tab size\n\t\t\tFlaggedOption opt2 = new FlaggedOption(\"tabsize\");\n\t\t\topt2.setLongFlag(\"tabsize\");\n\t\t\topt2.setStringParser(JSAP.INTEGER_PARSER);\n\t\t\topt2.setDefault(\"4\");\n\t\t\topt2.setHelp(\"Define tabulation size.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Level logging.\n\t\t\topt2 = new FlaggedOption(\"level\");\n\t\t\topt2.setLongFlag(\"level\");\n\t\t\topt2.setHelp(\"Level of the ouput messages about what spoon is doing. Default value is ALL level.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setDefault(Level.OFF.toString());\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Auto-import\n\t\t\tsw1 = new Switch(\"imports\");\n\t\t\tsw1.setLongFlag(\"with-imports\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tsw1.setHelp(\"Enable imports in generated files.\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// java compliance\n\t\t\topt2 = new FlaggedOption(\"compliance\");\n\t\t\topt2.setLongFlag(\"compliance\");\n\t\t\topt2.setHelp(\"Java source code compliance level (1,2,3,4,5, 6, 7 or 8).\");\n\t\t\topt2.setStringParser(JSAP.INTEGER_PARSER);\n\t\t\topt2.setDefault(\"8\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// compiler's encoding\n\t\t\topt2 = new FlaggedOption(\"encoding\");\n\t\t\topt2.setLongFlag(\"encoding\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setDefault(\"UTF-8\");\n\t\t\topt2.setHelp(\"Forces the compiler to use a specific encoding (UTF-8, UTF-16, ...).\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// setting Input files & Directory\n\t\t\topt2 = new FlaggedOption(\"input\");\n\t\t\topt2.setShortFlag('i');\n\t\t\topt2.setLongFlag(\"input\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"List of path to sources files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Processor qualified name\n\t\t\topt2 = new FlaggedOption(\"processors\");\n\t\t\topt2.setShortFlag('p');\n\t\t\topt2.setLongFlag(\"processors\");\n\t\t\topt2.setHelp(\"List of processor's qualified name to be used.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// setting input template\n\t\t\topt2 = new FlaggedOption(\"template\");\n\t\t\topt2.setShortFlag('t');\n\t\t\topt2.setLongFlag(\"template\");\n\t\t\topt2.setHelp(\"List of source templates.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"List of path to templates java files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Spooned output directory\n\t\t\topt2 = new FlaggedOption(\"output\");\n\t\t\topt2.setShortFlag('o');\n\t\t\topt2.setLongFlag(\"output\");\n\t\t\topt2.setDefault(OUTPUTDIR);\n\t\t\topt2.setHelp(\"Specify where to place generated java files.\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Location of properties files\n\t\t\topt2 = new FlaggedOption(\"properties\");\n\t\t\topt2.setLongFlag(\"properties\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"Directory to search for spoon properties files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Source classpath\n\t\t\topt2 = new FlaggedOption(\"source-classpath\");\n\t\t\topt2.setLongFlag(\"source-classpath\");\n\t\t\topt2.setHelp(\"An optional classpath to be passed to the internal \" + \"Java compiler when building or compiling the \" + \"input sources.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Template classpath\n\t\t\topt2 = new FlaggedOption(\"template-classpath\");\n\t\t\topt2.setLongFlag(\"template-classpath\");\n\t\t\topt2.setHelp(\"An optional classpath to be passed to the \" + \"internal Java compiler when building \" + \"the template sources.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Destination\n\t\t\topt2 = new FlaggedOption(\"destination\");\n\t\t\topt2.setShortFlag('d');\n\t\t\topt2.setLongFlag(\"destination\");\n\t\t\topt2.setDefault(\"spooned-classes\");\n\t\t\topt2.setHelp(\"An optional destination directory for the generated class files.\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Sets output type generation\n\t\t\topt2 = new FlaggedOption(\"output-type\");\n\t\t\topt2.setLongFlag(opt2.getID());\n\t\t\tString msg = \"States how to print the processed source code: \";\n\t\t\tint i = 0;\n\t\t\tfor (OutputType v : OutputType.values()) {\n\t\t\t\ti++;\n\t\t\t\tmsg += v.toString();\n\t\t\t\tif (i != OutputType.values().length) {\n\t\t\t\t\tmsg += \"|\";\n\t\t\t\t}\n\t\t\t}\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setHelp(msg);\n\t\t\topt2.setDefault(\"classes\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Enable compilation\n\t\t\tsw1 = new Switch(\"compile\");\n\t\t\tsw1.setLongFlag(sw1.getUsageName());\n\t\t\tsw1.setHelp(\"Enable compilation and output class files.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable pre-compilation\n\t\t\tsw1 = new Switch(\"precompile\");\n\t\t\tsw1.setLongFlag(\"precompile\");\n\t\t\tsw1.setHelp(\"Enable pre-compilation of input source files \" + \"before processing. Compiled classes \" + \"will be added to the classpath so that \" + \"they are accessible to the processing \"\n\t\t\t\t\t+ \"manager (typically, processors, \" + \"annotations, and templates should be \" + \"pre-compiled most of the time).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable building only outdated files\n\t\t\tsw1 = new Switch(\"buildOnlyOutdatedFiles\");\n\t\t\tsw1.setLongFlag(\"buildOnlyOutdatedFiles\");\n\t\t\tsw1.setHelp(\n\t\t\t\t\t\"Set Spoon to build only the source files that \" + \"have been modified since the latest \" + \"source code generation, for performance \" + \"purpose. Note that this option requires \"\n\t\t\t\t\t\t\t+ \"to have the --ouput-type option not set \" + \"to none. This option is not appropriate \" + \"to all kinds of processing. In particular \"\n\t\t\t\t\t\t\t+ \"processings that implement or rely on a \" + \"global analysis should avoid this option \" + \"because the processor will only have access \"\n\t\t\t\t\t\t\t+ \"to the outdated source code (the files \" + \"modified since the latest processing).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\tsw1 = new Switch(\"lines\");\n\t\t\tsw1.setLongFlag(\"lines\");\n\t\t\tsw1.setHelp(\"Set Spoon to try to preserve the original line \" + \"numbers when generating the source \" + \"code (may lead to human-unfriendly \" + \"formatting).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// nobinding\n\t\t\tsw1 = new Switch(\"noclasspath\");\n\t\t\tsw1.setShortFlag('x');\n\t\t\tsw1.setLongFlag(\"noclasspath\");\n\t\t\tsw1.setHelp(\"Does not assume a full classpath\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// show GUI\n\t\t\tsw1 = new Switch(\"gui\");\n\t\t\tsw1.setShortFlag('g');\n\t\t\tsw1.setLongFlag(\"gui\");\n\t\t\tsw1.setHelp(\"Show spoon model after processing\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Disable copy of resources.\n\t\t\tsw1 = new Switch(\"no-copy-resources\");\n\t\t\tsw1.setShortFlag('r');\n\t\t\tsw1.setLongFlag(\"no-copy-resources\");\n\t\t\tsw1.setHelp(\"Disable the copy of resources from source to destination folder.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable generation of javadoc.\n\t\t\tsw1 = new Switch(\"generate-javadoc\");\n\t\t\tsw1.setShortFlag('j');\n\t\t\tsw1.setLongFlag(\"generate-javadoc\");\n\t\t\tsw1.setHelp(\"Enable the generation of the javadoc.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\treturn jsap;\n\t\t} catch (JSAPException e) {\n\t\t\tthrow new SpoonException(e.getMessage(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the command-line given launching arguments in JSAP format.\n\t */\n\tprotected final JSAPResult getArguments() {\n\t\treturn parseArgs();\n\t}\n\n\tprotected void processArguments() {\n\t\tjsapActualArgs = getArguments();\n\n\t\tEnvironment environment = factory.getEnvironment();\n\t\t// environment initialization\n\t\tenvironment.setComplianceLevel(jsapActualArgs.getInt(\"compliance\"));\n\t\tenvironment.setLevel(jsapActualArgs.getString(\"level\"));\n\t\tLOGGER.setLevel(environment.getLevel());\n\t\tenvironment.setXmlRootFolder(jsapActualArgs.getFile(\"properties\"));\n\n\t\tenvironment.setAutoImports(jsapActualArgs.getBoolean(\"imports\"));\n\t\tenvironment.setNoClasspath(jsapActualArgs.getBoolean(\"noclasspath\"));\n\t\tenvironment.setPreserveLineNumbers(jsapActualArgs.getBoolean(\"lines\"));\n\n\t\tenvironment.setTabulationSize(jsapActualArgs.getInt(\"tabsize\"));\n\t\tenvironment.useTabulations(jsapActualArgs.getBoolean(\"tabs\"));\n\t\tenvironment.setCopyResources(!jsapActualArgs.getBoolean(\"no-copy-resources\"));\n\t\tenvironment.setGenerateJavadoc(jsapActualArgs.getBoolean(\"generate-javadoc\"));\n\n\t\tenvironment.setShouldCompile(jsapActualArgs.getBoolean(\"compile\"));\n\n\t\t// now we are ready to create a spoon compiler\n\t\tmodelBuilder = createCompiler();\n\n\t\tif (getArguments().getString(\"input\") != null) {\n\t\t\tfor (String s : getArguments().getString(\"input\").split(\"[\" + File.pathSeparatorChar + \"]\")) {\n\t\t\t\ttry {\n\t\t\t\t\tmodelBuilder.addInputSource(SpoonResourceHelper.createResource(new File(s)));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tthrow new SpoonException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getArguments().getFile(\"output\") != null) {\n\t\t\tsetSourceOutputDirectory(getArguments().getFile(\"output\"));\n\t\t}\n\n\t\t// Adding template from command-line\n\t\tif (getArguments().getString(\"template\") != null) {\n\t\t\tfor (String s : getArguments().getString(\"template\").split(\"[\" + File.pathSeparatorChar + \"]\")) {\n\t\t\t\ttry {\n\t\t\t\t\tmodelBuilder.addTemplateSource(SpoonResourceHelper.createResource(new File(s)));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tenvironment.report(null, Level.ERROR, \"Unable to add template file: \" + e.getMessage());\n\t\t\t\t\tLOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getArguments().getString(\"processors\") != null) {\n\t\t\tfor (String processorName : getArguments().getString(\"processors\").split(File.pathSeparator)) {\n\t\t\t\taddProcessor(processorName);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Gets the list of processor types to be initially applied during the\n\t * processing (-p option).\n\t */\n\tprotected java.util.List<String> getProcessorTypes() {\n\t\treturn processorTypes;\n\t}\n\n\t/**\n\t * Gets the list of processors instance to be initially applied during the\n\t * processing.\n\t */\n\tprotected List<Processor<? extends CtElement>> getProcessors() {\n\t\treturn processors;\n\t}\n\n\t/**\n\t * Parses the arguments given by the command line.\n\t *\n\t * @return the JSAP-presented arguments\n\t */\n\tprotected JSAPResult parseArgs() {\n\t\tif (jsapSpec == null) {\n\t\t\tthrow new IllegalStateException(\"no args, please call setArgs before\");\n\t\t}\n\t\tJSAPResult arguments = jsapSpec.parse(commandLineArgs);\n\t\tif (!arguments.success()) {\n\t\t\t// print out specific error messages describing the problems\n\t\t\tfor (java.util.Iterator<?> errs = arguments.getErrorMessageIterator(); errs.hasNext();) {\n\t\t\t\tSystem.err.println(\"Error: \" + errs.next());\n\t\t\t}\n\t\t}\n\t\tif (!arguments.success() || arguments.getBoolean(\"help\")) {\n\t\t\tSystem.err.println(getVersionMessage());\n\t\t\tSystem.err.println(\"Usage: java <launcher name> [option(s)]\");\n\t\t\tSystem.err.println();\n\t\t\tSystem.err.println(\"Options : \");\n\t\t\tSystem.err.println();\n\t\t\tSystem.err.println(jsapSpec.getHelp());\n\t\t\tSystem.exit(-1);\n\t\t}\n\n\t\treturn arguments;\n\t}\n\n\t/**\n\t * A default logger to be used by Spoon.\n\t */\n\tpublic static final Logger LOGGER = Logger.getLogger(Launcher.class);\n\n\t/**\n\t * Creates a new Spoon Java compiler in order to process and compile Java\n\t * source code.\n\t *\n\t * @param factory\n\t * \t\tthe factory this compiler works on\n\t */\n\tpublic SpoonCompiler createCompiler(Factory factory) {\n\t\tSpoonCompiler comp = new JDTBasedSpoonCompiler(factory);\n\t\tEnvironment env = getEnvironment();\n\t\t// building\n\t\tcomp.setEncoding(getArguments().getString(\"encoding\"));\n\t\tcomp.setBuildOnlyOutdatedFiles(jsapActualArgs.getBoolean(\"buildOnlyOutdatedFiles\"));\n\t\tcomp.setBinaryOutputDirectory(jsapActualArgs.getFile(\"destination\"));\n\t\tcomp.setSourceOutputDirectory(jsapActualArgs.getFile(\"output\"));\n\t\tcomp.setEncoding(jsapActualArgs.getString(\"encoding\"));\n\n\t\t// backward compatibility\n\t\t// we don't have to set the source classpath\n\t\tif (jsapActualArgs.contains(\"source-classpath\")) {\n\t\t\tcomp.setSourceClasspath(jsapActualArgs.getString(\"source-classpath\").split(System.getProperty(\"path.separator\")));\n\t\t}\n\n\t\tenv.debugMessage(\"output: \" + comp.getSourceOutputDirectory());\n\t\tenv.debugMessage(\"destination: \" + comp.getBinaryOutputDirectory());\n\t\tenv.debugMessage(\"source classpath: \" + Arrays.toString(comp.getSourceClasspath()));\n\t\tenv.debugMessage(\"template classpath: \" + Arrays.toString(comp.getTemplateClasspath()));\n\n\t\tif (jsapActualArgs.getBoolean(\"precompile\")) {\n\t\t\tcomp.compileInputSources();\n\t\t}\n\n\t\treturn comp;\n\t}\n\n\tpublic SpoonCompiler createCompiler(Factory factory, List<SpoonResource> inputSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\treturn c;\n\t}\n\n\t/**\n\t * Creates a new Spoon Java compiler in order to process and compile Java\n\t * source code.\n\t */\n\tpublic SpoonCompiler createCompiler(Factory factory, List<SpoonResource> inputSources, List<SpoonResource> templateSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\tc.addTemplateSources(templateSources);\n\t\treturn c;\n\t}\n\n\t@Override\n\tpublic SpoonCompiler createCompiler() {\n\t\treturn createCompiler(factory);\n\t}\n\n\t/**\n\t * Creates a new Spoon Java compiler with a default factory and a list of\n\t * input sources.\n\t */\n\tpublic SpoonCompiler createCompiler(List<SpoonResource> inputSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\treturn c;\n\t}\n\n\t@Override\n\tpublic Factory createFactory() {\n\t\treturn new FactoryImpl(new DefaultCoreFactory(), createEnvironment());\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic Environment createEnvironment() {\n\t\treturn new StandardEnvironment();\n\t}\n\n\tpublic JavaOutputProcessor createOutputWriter(File sourceOutputDir, Environment environment) {\n\t\treturn new JavaOutputProcessor(sourceOutputDir, createPrettyPrinter());\n\t}\n\n\tpublic PrettyPrinter createPrettyPrinter() {\n\t\treturn new DefaultJavaPrettyPrinter(getEnvironment());\n\t}\n\n\t/**\n\t * Runs Spoon using the given compiler, with the given run options. A Spoon\n\t * run will perform the following tasks:\n\t *\n\t * <ol>\n\t * <li>Pre-compilation (optional):\n\t * {@link SpoonCompiler#compileInputSources()}.<\/li>\n\t * <li>Source model building in the given compiler:\n\t * {@link SpoonCompiler#build()}.<\/li>\n\t * <li>Template model building in the given factory (if any template source\n\t * is given): {@link SpoonCompiler#build()}.<\/li>\n\t * <li>Model processing with the list of given processors if any:\n\t * {@link SpoonCompiler#process(List)}.<\/li>\n\t * <li>Processed Source code printing and generation (can be disabled with\n\t * {@link OutputType#NO_OUTPUT}):\n\t * {@link SpoonCompiler#generateProcessedSourceFiles(OutputType)}.<\/li>\n\t * <li>Processed source code compilation (optional):\n\t * {@link SpoonCompiler#compile()}.<\/li>\n\t * <\/ol>\n\t */\n\t@Override\n\tpublic void run() {\n\t\tEnvironment env = modelBuilder.getFactory().getEnvironment();\n\t\tenv.reportProgressMessage(getVersionMessage());\n\t\tenv.reportProgressMessage(\"running Spoon...\");\n\n\t\tenv.reportProgressMessage(\"start processing...\");\n\n\t\tlong t = 0;\n\t\tlong tstart = System.currentTimeMillis();\n\n\t\tbuildModel();\n\n\t\tprocess();\n\n\t\tprettyprint();\n\n\t\tif (env.shouldCompile()) {\n\t\t\tmodelBuilder.compile();\n\t\t}\n\n\t\tt = System.currentTimeMillis();\n\n\t\tenv.debugMessage(\"program spooning done in \" + (t - tstart) + \" ms\");\n\t\tenv.reportEnd();\n\n\t}\n\n\tprivate String getVersionMessage() {\n\t\treturn \"Spoon version \" + ResourceBundle.getBundle(\"spoon\").getString(\"application.version\");\n\t}\n\n\tpublic static final IOFileFilter RESOURCES_FILE_FILTER = new IOFileFilter() {\n\t\t@Override\n\t\tpublic boolean accept(File file) {\n\t\t\treturn !file.getName().endsWith(\".java\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean accept(File file, String s) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tpublic static final IOFileFilter ALL_DIR_FILTER = new IOFileFilter() {\n\t\t@Override\n\t\tpublic boolean accept(File file) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean accept(File file, String s) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t@Override\n\tpublic void buildModel() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\tmodelBuilder.build();\n\t\tgetEnvironment().debugMessage(\"model built in \" + (System.currentTimeMillis() - tstart));\n\t}\n\n\t@Override\n\tpublic void process() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\tmodelBuilder.process(getProcessorTypes());\n\t\tmodelBuilder.process(getProcessors());\n\t\tgetEnvironment().debugMessage(\"model processed in \" + (System.currentTimeMillis() - tstart) + \" ms\");\n\t}\n\n\t@Override\n\tpublic void prettyprint() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\ttry {\n\t\t\tOutputType outputType = OutputType.fromString(jsapActualArgs.getString(\"output-type\"));\n\t\t\tmodelBuilder.generateProcessedSourceFiles(outputType);\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\n\t\tif (getEnvironment().isCopyResources()) {\n\t\t\tfor (File dirInputSource : modelBuilder.getInputSources()) {\n\t\t\t\tif (dirInputSource.isDirectory()) {\n\t\t\t\t\tfinal Collection<?> resources = FileUtils.listFiles(dirInputSource, RESOURCES_FILE_FILTER, ALL_DIR_FILTER);\n\t\t\t\t\tfor (Object resource : resources) {\n\t\t\t\t\t\tfinal String resourceParentPath = ((File) resource).getParent();\n\t\t\t\t\t\tfinal String packageDir = resourceParentPath.substring(dirInputSource.getPath().length());\n\t\t\t\t\t\tfinal String targetDirectory = modelBuilder.getSourceOutputDirectory() + packageDir;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFileUtils.copyFileToDirectory((File) resource, new File(targetDirectory));\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tthrow new SpoonException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetEnvironment().debugMessage(\"pretty-printed in \" + (System.currentTimeMillis() - tstart) + \" ms\");\n\t}\n\n\tpublic SpoonModelBuilder getModelBuilder() {\n\t\treturn modelBuilder;\n\t}\n\n\t@Override\n\tpublic void setSourceOutputDirectory(String path) {\n\t\tsetSourceOutputDirectory(new File(path));\n\t}\n\n\t@Override\n\tpublic void setSourceOutputDirectory(File outputDirectory) {\n\t\tmodelBuilder.setSourceOutputDirectory(outputDirectory);\n\t\tgetEnvironment().setDefaultFileGenerator(createOutputWriter(outputDirectory, getEnvironment()));\n\t}\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(String path) {\n\t\tsetBinaryOutputDirectory(new File(path));\n\t}\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(File outputDirectory) {\n\t\tmodelBuilder.setBinaryOutputDirectory(outputDirectory);\n\t}\n\n}",
        "newFile": "/*\n * Spoon - http://spoon.gforge.inria.fr/\n * Copyright (C) 2006 INRIA Futurs <renaud.pawlak@inria.fr>\n *\n * This software is governed by the CeCILL-C License under French law and\n * abiding by the rules of distribution of free software. You can use, modify\n * and/or redistribute the software under the terms of the CeCILL-C license as\n * circulated by CEA, CNRS and INRIA at http://www.cecill.info.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C license and that you accept its terms.\n */\npackage spoon;\n\nimport com.martiansoftware.jsap.FlaggedOption;\nimport com.martiansoftware.jsap.JSAP;\nimport com.martiansoftware.jsap.JSAPException;\nimport com.martiansoftware.jsap.JSAPResult;\nimport com.martiansoftware.jsap.Switch;\nimport com.martiansoftware.jsap.stringparsers.FileStringParser;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonCompiler;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.JavaOutputProcessor;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.compiler.FileSystemFile;\nimport spoon.support.compiler.FileSystemFolder;\nimport spoon.support.compiler.jdt.JDTBasedSpoonCompiler;\nimport spoon.support.gui.SpoonModelTree;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.ResourceBundle;\n\n/**\n * This class implements an integrated command-line launcher for processing\n * programs at compile-time using the JDT-based builder (Eclipse). It takes\n * arguments that allow building, processing, printing, and compiling Java\n * programs. Launch with no arguments (see {@link #main(String[])}) for detailed\n * usage.\n */\npublic class Launcher implements SpoonAPI {\n\n\tpublic static final String OUTPUTDIR = \"spooned\";\n\n\tprivate Factory factory = createFactory();\n\n\tprivate SpoonCompiler modelBuilder;\n\n\tprivate String[] commandLineArgs = new String[0];\n\n\t/**\n\t * Contains the arguments accepted by this launcher (available after\n\t * construction and accessible by sub-classes).\n\t */\n\tprivate static JSAP jsapSpec;\n\tprotected JSAPResult jsapActualArgs;\n\n\tprivate List<String> processorTypes = new ArrayList<String>();\n\tprivate List<Processor<? extends CtElement>> processors = new ArrayList<Processor<? extends CtElement>>();\n\n\t/**\n\t * A default program entry point (instantiates a launcher with the given\n\t * arguments and calls {@link #run()}).\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Launcher().run(args);\n\t}\n\n\t@Override\n\tpublic void run(String[] args) {\n\t\tthis.setArgs(args);\n\t\tif (args.length != 0) {\n\t\t\tthis.run();\n\t\t\t// display GUI\n\t\t\tif (this.jsapActualArgs.getBoolean(\"gui\")) {\n\t\t\t\tnew SpoonModelTree(getFactory());\n\t\t\t}\n\t\t} else {\n\t\t\tthis.printUsage();\n\t\t}\n\t}\n\n\tpublic void setArgs(String[] args2) {\n\t\tthis.commandLineArgs = args2;\n\t\tprocessArguments();\n\t}\n\n\tpublic void printUsage() {\n\t\tthis.commandLineArgs = new String[] { \"--help\" };\n\t\tprocessArguments();\n\t}\n\n\tstatic {\n\t\tjsapSpec = defineArgs();\n\t}\n\n\t/**\n\t * Constructor with no arguments.\n\t */\n\tpublic Launcher() {\n\t\tprocessArguments();\n\t}\n\n\t@Override\n\tpublic void addInputResource(String path) {\n\t\tFile file = new File(path);\n\t\tif (file.isDirectory()) {\n\t\t\taddInputResource(new FileSystemFolder(file));\n\t\t} else {\n\t\t\taddInputResource(new FileSystemFile(file));\n\t\t}\n\t}\n\n\tprivate void addInputResource(SpoonResource resource) {\n\t\tmodelBuilder.addInputSource(resource);\n\t}\n\n\t@Override\n\tpublic void addProcessor(String name) {\n\t\tprocessorTypes.add(name);\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> void addProcessor(Processor<T> processor) {\n\t\tprocessors.add(processor);\n\t}\n\n\tpublic void addTemplateResource(SpoonResource resource) {\n\t\tmodelBuilder.addTemplateSource(resource);\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn factory.getEnvironment();\n\t}\n\n\t/**\n\t * Defines the common arguments for sub-launchers.\n\t *\n\t * @return the JSAP arguments\n\t */\n\tprotected static JSAP defineArgs() {\n\t\ttry {\n\t\t\t// Verbose output\n\t\t\tJSAP jsap = new JSAP();\n\n\t\t\t// help\n\t\t\tSwitch sw1 = new Switch(\"help\");\n\t\t\tsw1.setShortFlag('h');\n\t\t\tsw1.setLongFlag(\"help\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Tabs\n\t\t\tsw1 = new Switch(\"tabs\");\n\t\t\tsw1.setLongFlag(\"tabs\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tsw1.setHelp(\"Use tabulations instead of spaces in the generated code (use spaces by default).\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Tab size\n\t\t\tFlaggedOption opt2 = new FlaggedOption(\"tabsize\");\n\t\t\topt2.setLongFlag(\"tabsize\");\n\t\t\topt2.setStringParser(JSAP.INTEGER_PARSER);\n\t\t\topt2.setDefault(\"4\");\n\t\t\topt2.setHelp(\"Define tabulation size.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Level logging.\n\t\t\topt2 = new FlaggedOption(\"level\");\n\t\t\topt2.setLongFlag(\"level\");\n\t\t\topt2.setHelp(\"Level of the ouput messages about what spoon is doing. Default value is ALL level.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setDefault(Level.OFF.toString());\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Auto-import\n\t\t\tsw1 = new Switch(\"imports\");\n\t\t\tsw1.setLongFlag(\"with-imports\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tsw1.setHelp(\"Enable imports in generated files.\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// java compliance\n\t\t\topt2 = new FlaggedOption(\"compliance\");\n\t\t\topt2.setLongFlag(\"compliance\");\n\t\t\topt2.setHelp(\"Java source code compliance level (1,2,3,4,5, 6, 7 or 8).\");\n\t\t\topt2.setStringParser(JSAP.INTEGER_PARSER);\n\t\t\topt2.setDefault(\"8\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// compiler's encoding\n\t\t\topt2 = new FlaggedOption(\"encoding\");\n\t\t\topt2.setLongFlag(\"encoding\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setDefault(\"UTF-8\");\n\t\t\topt2.setHelp(\"Forces the compiler to use a specific encoding (UTF-8, UTF-16, ...).\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// setting Input files & Directory\n\t\t\topt2 = new FlaggedOption(\"input\");\n\t\t\topt2.setShortFlag('i');\n\t\t\topt2.setLongFlag(\"input\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"List of path to sources files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Processor qualified name\n\t\t\topt2 = new FlaggedOption(\"processors\");\n\t\t\topt2.setShortFlag('p');\n\t\t\topt2.setLongFlag(\"processors\");\n\t\t\topt2.setHelp(\"List of processor's qualified name to be used.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// setting input template\n\t\t\topt2 = new FlaggedOption(\"template\");\n\t\t\topt2.setShortFlag('t');\n\t\t\topt2.setLongFlag(\"template\");\n\t\t\topt2.setHelp(\"List of source templates.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"List of path to templates java files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Spooned output directory\n\t\t\topt2 = new FlaggedOption(\"output\");\n\t\t\topt2.setShortFlag('o');\n\t\t\topt2.setLongFlag(\"output\");\n\t\t\topt2.setDefault(OUTPUTDIR);\n\t\t\topt2.setHelp(\"Specify where to place generated java files.\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Location of properties files\n\t\t\topt2 = new FlaggedOption(\"properties\");\n\t\t\topt2.setLongFlag(\"properties\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\topt2.setHelp(\"Directory to search for spoon properties files.\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Source classpath\n\t\t\topt2 = new FlaggedOption(\"source-classpath\");\n\t\t\topt2.setLongFlag(\"source-classpath\");\n\t\t\topt2.setHelp(\"An optional classpath to be passed to the internal \" + \"Java compiler when building or compiling the \" + \"input sources.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Template classpath\n\t\t\topt2 = new FlaggedOption(\"template-classpath\");\n\t\t\topt2.setLongFlag(\"template-classpath\");\n\t\t\topt2.setHelp(\"An optional classpath to be passed to the \" + \"internal Java compiler when building \" + \"the template sources.\");\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Destination\n\t\t\topt2 = new FlaggedOption(\"destination\");\n\t\t\topt2.setShortFlag('d');\n\t\t\topt2.setLongFlag(\"destination\");\n\t\t\topt2.setDefault(\"spooned-classes\");\n\t\t\topt2.setHelp(\"An optional destination directory for the generated class files.\");\n\t\t\topt2.setStringParser(FileStringParser.getParser());\n\t\t\topt2.setRequired(false);\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Sets output type generation\n\t\t\topt2 = new FlaggedOption(\"output-type\");\n\t\t\topt2.setLongFlag(opt2.getID());\n\t\t\tString msg = \"States how to print the processed source code: \";\n\t\t\tint i = 0;\n\t\t\tfor (OutputType v : OutputType.values()) {\n\t\t\t\ti++;\n\t\t\t\tmsg += v.toString();\n\t\t\t\tif (i != OutputType.values().length) {\n\t\t\t\t\tmsg += \"|\";\n\t\t\t\t}\n\t\t\t}\n\t\t\topt2.setStringParser(JSAP.STRING_PARSER);\n\t\t\topt2.setHelp(msg);\n\t\t\topt2.setDefault(\"classes\");\n\t\t\tjsap.registerParameter(opt2);\n\n\t\t\t// Enable compilation\n\t\t\tsw1 = new Switch(\"compile\");\n\t\t\tsw1.setLongFlag(sw1.getUsageName());\n\t\t\tsw1.setHelp(\"Enable compilation and output class files.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable pre-compilation\n\t\t\tsw1 = new Switch(\"precompile\");\n\t\t\tsw1.setLongFlag(\"precompile\");\n\t\t\tsw1.setHelp(\"Enable pre-compilation of input source files \" + \"before processing. Compiled classes \" + \"will be added to the classpath so that \" + \"they are accessible to the processing \"\n\t\t\t\t\t+ \"manager (typically, processors, \" + \"annotations, and templates should be \" + \"pre-compiled most of the time).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable building only outdated files\n\t\t\tsw1 = new Switch(\"buildOnlyOutdatedFiles\");\n\t\t\tsw1.setLongFlag(\"buildOnlyOutdatedFiles\");\n\t\t\tsw1.setHelp(\n\t\t\t\t\t\"Set Spoon to build only the source files that \" + \"have been modified since the latest \" + \"source code generation, for performance \" + \"purpose. Note that this option requires \"\n\t\t\t\t\t\t\t+ \"to have the --ouput-type option not set \" + \"to none. This option is not appropriate \" + \"to all kinds of processing. In particular \"\n\t\t\t\t\t\t\t+ \"processings that implement or rely on a \" + \"global analysis should avoid this option \" + \"because the processor will only have access \"\n\t\t\t\t\t\t\t+ \"to the outdated source code (the files \" + \"modified since the latest processing).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\tsw1 = new Switch(\"lines\");\n\t\t\tsw1.setLongFlag(\"lines\");\n\t\t\tsw1.setHelp(\"Set Spoon to try to preserve the original line \" + \"numbers when generating the source \" + \"code (may lead to human-unfriendly \" + \"formatting).\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// nobinding\n\t\t\tsw1 = new Switch(\"noclasspath\");\n\t\t\tsw1.setShortFlag('x');\n\t\t\tsw1.setLongFlag(\"noclasspath\");\n\t\t\tsw1.setHelp(\"Does not assume a full classpath\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// show GUI\n\t\t\tsw1 = new Switch(\"gui\");\n\t\t\tsw1.setShortFlag('g');\n\t\t\tsw1.setLongFlag(\"gui\");\n\t\t\tsw1.setHelp(\"Show spoon model after processing\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Disable copy of resources.\n\t\t\tsw1 = new Switch(\"no-copy-resources\");\n\t\t\tsw1.setShortFlag('r');\n\t\t\tsw1.setLongFlag(\"no-copy-resources\");\n\t\t\tsw1.setHelp(\"Disable the copy of resources from source to destination folder.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\t// Enable generation of javadoc.\n\t\t\tsw1 = new Switch(\"generate-javadoc\");\n\t\t\tsw1.setShortFlag('j');\n\t\t\tsw1.setLongFlag(\"generate-javadoc\");\n\t\t\tsw1.setHelp(\"Enable the generation of the javadoc.\");\n\t\t\tsw1.setDefault(\"false\");\n\t\t\tjsap.registerParameter(sw1);\n\n\t\t\treturn jsap;\n\t\t} catch (JSAPException e) {\n\t\t\tthrow new SpoonException(e.getMessage(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the command-line given launching arguments in JSAP format.\n\t */\n\tprotected final JSAPResult getArguments() {\n\t\treturn parseArgs();\n\t}\n\n\tprotected void processArguments() {\n\t\tjsapActualArgs = getArguments();\n\n\t\tEnvironment environment = factory.getEnvironment();\n\t\t// environment initialization\n\t\tenvironment.setComplianceLevel(jsapActualArgs.getInt(\"compliance\"));\n\t\tenvironment.setLevel(jsapActualArgs.getString(\"level\"));\n\t\tLOGGER.setLevel(environment.getLevel());\n\t\tenvironment.setXmlRootFolder(jsapActualArgs.getFile(\"properties\"));\n\n\t\tenvironment.setAutoImports(jsapActualArgs.getBoolean(\"imports\"));\n\t\tenvironment.setNoClasspath(jsapActualArgs.getBoolean(\"noclasspath\"));\n\t\tenvironment.setPreserveLineNumbers(jsapActualArgs.getBoolean(\"lines\"));\n\n\t\tenvironment.setTabulationSize(jsapActualArgs.getInt(\"tabsize\"));\n\t\tenvironment.useTabulations(jsapActualArgs.getBoolean(\"tabs\"));\n\t\tenvironment.setCopyResources(!jsapActualArgs.getBoolean(\"no-copy-resources\"));\n\t\tenvironment.setGenerateJavadoc(jsapActualArgs.getBoolean(\"generate-javadoc\"));\n\n\t\tenvironment.setShouldCompile(jsapActualArgs.getBoolean(\"compile\"));\n\n\t\t// now we are ready to create a spoon compiler\n\t\tmodelBuilder = createCompiler();\n\n\t\tif (getArguments().getString(\"input\") != null) {\n\t\t\tfor (String s : getArguments().getString(\"input\").split(\"[\" + File.pathSeparatorChar + \"]\")) {\n\t\t\t\ttry {\n\t\t\t\t\tmodelBuilder.addInputSource(SpoonResourceHelper.createResource(new File(s)));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tthrow new SpoonException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getArguments().getFile(\"output\") != null) {\n\t\t\tsetSourceOutputDirectory(getArguments().getFile(\"output\"));\n\t\t}\n\n\t\t// Adding template from command-line\n\t\tif (getArguments().getString(\"template\") != null) {\n\t\t\tfor (String s : getArguments().getString(\"template\").split(\"[\" + File.pathSeparatorChar + \"]\")) {\n\t\t\t\ttry {\n\t\t\t\t\tmodelBuilder.addTemplateSource(SpoonResourceHelper.createResource(new File(s)));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tenvironment.report(null, Level.ERROR, \"Unable to add template file: \" + e.getMessage());\n\t\t\t\t\tLOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getArguments().getString(\"processors\") != null) {\n\t\t\tfor (String processorName : getArguments().getString(\"processors\").split(File.pathSeparator)) {\n\t\t\t\taddProcessor(processorName);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Gets the list of processor types to be initially applied during the\n\t * processing (-p option).\n\t */\n\tprotected java.util.List<String> getProcessorTypes() {\n\t\treturn processorTypes;\n\t}\n\n\t/**\n\t * Gets the list of processors instance to be initially applied during the\n\t * processing.\n\t */\n\tprotected List<Processor<? extends CtElement>> getProcessors() {\n\t\treturn processors;\n\t}\n\n\t/**\n\t * Parses the arguments given by the command line.\n\t *\n\t * @return the JSAP-presented arguments\n\t */\n\tprotected JSAPResult parseArgs() {\n\t\tif (jsapSpec == null) {\n\t\t\tthrow new IllegalStateException(\"no args, please call setArgs before\");\n\t\t}\n\t\tJSAPResult arguments = jsapSpec.parse(commandLineArgs);\n\t\tif (!arguments.success()) {\n\t\t\t// print out specific error messages describing the problems\n\t\t\tfor (java.util.Iterator<?> errs = arguments.getErrorMessageIterator(); errs.hasNext();) {\n\t\t\t\tSystem.err.println(\"Error: \" + errs.next());\n\t\t\t}\n\t\t}\n\t\tif (!arguments.success() || arguments.getBoolean(\"help\")) {\n\t\t\tSystem.err.println(getVersionMessage());\n\t\t\tSystem.err.println(\"Usage: java <launcher name> [option(s)]\");\n\t\t\tSystem.err.println();\n\t\t\tSystem.err.println(\"Options : \");\n\t\t\tSystem.err.println();\n\t\t\tSystem.err.println(jsapSpec.getHelp());\n\t\t\tSystem.exit(-1);\n\t\t}\n\n\t\treturn arguments;\n\t}\n\n\t/**\n\t * A default logger to be used by Spoon.\n\t */\n\tpublic static final Logger LOGGER = Logger.getLogger(Launcher.class);\n\n\t/**\n\t * Creates a new Spoon Java compiler in order to process and compile Java\n\t * source code.\n\t *\n\t * @param factory\n\t * \t\tthe factory this compiler works on\n\t */\n\tpublic SpoonCompiler createCompiler(Factory factory) {\n\t\tSpoonCompiler comp = new JDTBasedSpoonCompiler(factory);\n\t\tEnvironment env = getEnvironment();\n\t\t// building\n\t\tcomp.setEncoding(getArguments().getString(\"encoding\"));\n\t\tcomp.setBuildOnlyOutdatedFiles(jsapActualArgs.getBoolean(\"buildOnlyOutdatedFiles\"));\n\t\tcomp.setBinaryOutputDirectory(jsapActualArgs.getFile(\"destination\"));\n\t\tcomp.setSourceOutputDirectory(jsapActualArgs.getFile(\"output\"));\n\t\tcomp.setEncoding(jsapActualArgs.getString(\"encoding\"));\n\n\t\t// backward compatibility\n\t\t// we don't have to set the source classpath\n\t\tif (jsapActualArgs.contains(\"source-classpath\")) {\n\t\t\tcomp.setSourceClasspath(jsapActualArgs.getString(\"source-classpath\").split(System.getProperty(\"path.separator\")));\n\t\t}\n\n\t\tenv.debugMessage(\"output: \" + comp.getSourceOutputDirectory());\n\t\tenv.debugMessage(\"destination: \" + comp.getBinaryOutputDirectory());\n\t\tenv.debugMessage(\"source classpath: \" + Arrays.toString(comp.getSourceClasspath()));\n\t\tenv.debugMessage(\"template classpath: \" + Arrays.toString(comp.getTemplateClasspath()));\n\n\t\tif (jsapActualArgs.getBoolean(\"precompile\")) {\n\t\t\tcomp.compileInputSources();\n\t\t}\n\n\t\treturn comp;\n\t}\n\n\tpublic SpoonCompiler createCompiler(Factory factory, List<SpoonResource> inputSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\treturn c;\n\t}\n\n\t/**\n\t * Creates a new Spoon Java compiler in order to process and compile Java\n\t * source code.\n\t */\n\tpublic SpoonCompiler createCompiler(Factory factory, List<SpoonResource> inputSources, List<SpoonResource> templateSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\tc.addTemplateSources(templateSources);\n\t\treturn c;\n\t}\n\n\t@Override\n\tpublic SpoonCompiler createCompiler() {\n\t\treturn createCompiler(factory);\n\t}\n\n\t/**\n\t * Creates a new Spoon Java compiler with a default factory and a list of\n\t * input sources.\n\t */\n\tpublic SpoonCompiler createCompiler(List<SpoonResource> inputSources) {\n\t\tSpoonCompiler c = createCompiler(factory);\n\t\tc.addInputSources(inputSources);\n\t\treturn c;\n\t}\n\n\t@Override\n\tpublic Factory createFactory() {\n\t\treturn new FactoryImpl(new DefaultCoreFactory(), createEnvironment());\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic Environment createEnvironment() {\n\t\treturn new StandardEnvironment();\n\t}\n\n\tpublic JavaOutputProcessor createOutputWriter(File sourceOutputDir, Environment environment) {\n\t\treturn new JavaOutputProcessor(sourceOutputDir, createPrettyPrinter());\n\t}\n\n\tpublic PrettyPrinter createPrettyPrinter() {\n\t\treturn new DefaultJavaPrettyPrinter(getEnvironment());\n\t}\n\n\t/**\n\t * Runs Spoon using the given compiler, with the given run options. A Spoon\n\t * run will perform the following tasks:\n\t *\n\t * <ol>\n\t * <li>Pre-compilation (optional):\n\t * {@link SpoonCompiler#compileInputSources()}.<\/li>\n\t * <li>Source model building in the given compiler:\n\t * {@link SpoonCompiler#build()}.<\/li>\n\t * <li>Template model building in the given factory (if any template source\n\t * is given): {@link SpoonCompiler#build()}.<\/li>\n\t * <li>Model processing with the list of given processors if any:\n\t * {@link SpoonCompiler#instantiateAndProcess(List)}.<\/li>\n\t * <li>Processed Source code printing and generation (can be disabled with\n\t * {@link OutputType#NO_OUTPUT}):\n\t * {@link SpoonCompiler#generateProcessedSourceFiles(OutputType)}.<\/li>\n\t * <li>Processed source code compilation (optional):\n\t * {@link SpoonCompiler#compile()}.<\/li>\n\t * <\/ol>\n\t */\n\t@Override\n\tpublic void run() {\n\t\tEnvironment env = modelBuilder.getFactory().getEnvironment();\n\t\tenv.reportProgressMessage(getVersionMessage());\n\t\tenv.reportProgressMessage(\"running Spoon...\");\n\n\t\tenv.reportProgressMessage(\"start processing...\");\n\n\t\tlong t = 0;\n\t\tlong tstart = System.currentTimeMillis();\n\n\t\tbuildModel();\n\n\t\tprocess();\n\n\t\tprettyprint();\n\n\t\tif (env.shouldCompile()) {\n\t\t\tmodelBuilder.compile();\n\t\t}\n\n\t\tt = System.currentTimeMillis();\n\n\t\tenv.debugMessage(\"program spooning done in \" + (t - tstart) + \" ms\");\n\t\tenv.reportEnd();\n\n\t}\n\n\tprivate String getVersionMessage() {\n\t\treturn \"Spoon version \" + ResourceBundle.getBundle(\"spoon\").getString(\"application.version\");\n\t}\n\n\tpublic static final IOFileFilter RESOURCES_FILE_FILTER = new IOFileFilter() {\n\t\t@Override\n\t\tpublic boolean accept(File file) {\n\t\t\treturn !file.getName().endsWith(\".java\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean accept(File file, String s) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tpublic static final IOFileFilter ALL_DIR_FILTER = new IOFileFilter() {\n\t\t@Override\n\t\tpublic boolean accept(File file) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean accept(File file, String s) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t@Override\n\tpublic void buildModel() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\tmodelBuilder.build();\n\t\tgetEnvironment().debugMessage(\"model built in \" + (System.currentTimeMillis() - tstart));\n\t}\n\n\t@Override\n\tpublic void process() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\tmodelBuilder.instantiateAndProcess(getProcessorTypes());\n\t\tmodelBuilder.process(getProcessors());\n\t\tgetEnvironment().debugMessage(\"model processed in \" + (System.currentTimeMillis() - tstart) + \" ms\");\n\t}\n\n\t@Override\n\tpublic void prettyprint() {\n\t\tlong tstart = System.currentTimeMillis();\n\t\ttry {\n\t\t\tOutputType outputType = OutputType.fromString(jsapActualArgs.getString(\"output-type\"));\n\t\t\tmodelBuilder.generateProcessedSourceFiles(outputType);\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\n\t\tif (getEnvironment().isCopyResources()) {\n\t\t\tfor (File dirInputSource : modelBuilder.getInputSources()) {\n\t\t\t\tif (dirInputSource.isDirectory()) {\n\t\t\t\t\tfinal Collection<?> resources = FileUtils.listFiles(dirInputSource, RESOURCES_FILE_FILTER, ALL_DIR_FILTER);\n\t\t\t\t\tfor (Object resource : resources) {\n\t\t\t\t\t\tfinal String resourceParentPath = ((File) resource).getParent();\n\t\t\t\t\t\tfinal String packageDir = resourceParentPath.substring(dirInputSource.getPath().length());\n\t\t\t\t\t\tfinal String targetDirectory = modelBuilder.getSourceOutputDirectory() + packageDir;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFileUtils.copyFileToDirectory((File) resource, new File(targetDirectory));\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tthrow new SpoonException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetEnvironment().debugMessage(\"pretty-printed in \" + (System.currentTimeMillis() - tstart) + \" ms\");\n\t}\n\n\tpublic SpoonModelBuilder getModelBuilder() {\n\t\treturn modelBuilder;\n\t}\n\n\t@Override\n\tpublic void setSourceOutputDirectory(String path) {\n\t\tsetSourceOutputDirectory(new File(path));\n\t}\n\n\t@Override\n\tpublic void setSourceOutputDirectory(File outputDirectory) {\n\t\tmodelBuilder.setSourceOutputDirectory(outputDirectory);\n\t\tgetEnvironment().setDefaultFileGenerator(createOutputWriter(outputDirectory, getEnvironment()));\n\t}\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(String path) {\n\t\tsetBinaryOutputDirectory(new File(path));\n\t}\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(File outputDirectory) {\n\t\tmodelBuilder.setBinaryOutputDirectory(outputDirectory);\n\t}\n\n}",
        "location": {
          "path": "src/main/java/spoon/Launcher.java",
          "type": "Class",
          "class": "spoon.Launcher"
        }
      }
    ],
    "id": 402,
    "title": "refactor(api): Deprecates process method for a new one.",
    "body": "In SpoonModelBuilder, we had two methods very semilar in their\r\nsignature. To avoid confusing these methods, we deprecates one of\r\nthem with a method name more explicit.",
    "url": "/repos/INRIA/spoon/pulls/402"
  },
  "repository": "spoon",
  "user": "INRIA"
};
    $scope.onProgress = false;
    $scope.toggleSidenav = function (menuId) {
        $mdSidenav(menuId).toggle();
    };
    /*for(var i in $scope.prettyPR.pullrequest.changes) {
        $scope.prettyPR.pullrequest.changes[i].patch = $scope.prettyPR.pullrequest.changes[i].patch.replace(/   /g, "   ");

        var oldFile = $scope.prettyPR.pullrequest.changes[i].oldFile;
        var newFile = $scope.prettyPR.pullrequest.changes[i].newFile;

        for(var j in $scope.prettyPR.pullrequest.changes[i].actions) {
            var action = $scope.prettyPR.pullrequest.changes[i].actions[j];
            var location = action.location;

            location.line;

            if(action.action == "Delete") {
                output = oldFile.substring(0, location.sourceStart);
            } else {
                output = newFile.substring(0, location.sourceStart);
            }
            output += " ___" + action.action + "___ ";

            if(action.action == "Delete") {
                output += oldFile.substring(location.sourceStart, location.sourceEnd + 1);
            } else {
                output += newFile.substring(location.sourceStart, location.sourceEnd + 1);
            }
            output += " ___" + action.action + "___ ";
            output += " \\\\\\" + action.action + "\\\\\\ ";
            if(action.action == "Delete") {
                output += oldFile.substring(location.sourceEnd + 1, oldFile.length);
                $scope.prettyPR.pullrequest.changes[i].oldFile = output;
            } else {
                output += newFile.substring(location.sourceEnd + 1, newFile.length);
                $scope.prettyPR.pullrequest.changes[i].newFile = output;
            }
        }
    }*/

    $scope.submit = function () {
        $scope.onProgress = true;
        $scope.prettyPR = null;
        $scope.error = null;
        $http.get("/api/v.0/" + $scope.pr.user + "/" + $scope.pr.repo + "/" + $scope.pr.id).then(function (data) {
            $scope.prettyPR = data.data;
            $scope.onProgress = false;
        }, function (error) {
            $scope.error = error.data;
            $scope.onProgress = false;
        });
    }

}]).directive("markdown", function ($compile, $http) {
    var converter = new showdown.Converter();
    return {
        restrict: 'E',
        replace: true,
        link: function (scope, element, attrs) {
            if ("src" in attrs) {
                $http.get(attrs.src).then(function(data) {
                    element.html(converter.makeHtml(data.data));
                });
            } else if ("text" in attrs) {
                element.html(converter.makeHtml(attrs.text));
            } else {
                element.html(converter.makeHtml(element.text()));
            }
        }
    };
}).directive("diffClass", function ($compile, $http) {
    function generateLineNumber(line) {
        return "<td class=\"lineNumber\">"  + (line!=null?(line + 1):'') + "</td>";
    }
    function generateTable() {
        return "<table class=\"codeDiff\" cellpadding=\"0\" cellspacing=\"0\"><colgroup><col width=\"44\"><col><col width=\"44\"><col></colgroup>";
    }
    function formatCode(content) {
        return Prism.highlight(content, Prism.languages.java);
    }
    return {
        restrict: 'E',
        replace: true,
        scope: {
          change: '=change'
        },
        link: function (scope, element, attrs) {
            element.html("");
            var oldFile = scope.change.oldFile;
            var newFile = scope.change.newFile;

            var re=/\r\n|\n\r|\n|\r/g;
            function splitLine(content) {
                return content.split("\n");
            }
            
            if(oldFile) {
                oldLines = splitLine(oldFile);
            } else {
                oldLines=[];
            }
            if(newFile) {
                newLines = splitLine(newFile);
            } else {
                newLines=[];
            }

            var changedLineOld = [];
            var changedLineNew = [];
            for(var j in scope.change.actions) {
                var action = scope.change.actions[j];
                if(action.newLocation) {
                    for (var i = action.newLocation.line; i <= action.newLocation.endLine; i++) {
                        if(!changedLineNew[i]) {
                            changedLineNew[i] = []
                        }
                        changedLineNew[i].push(action);
                    };
                } 
                if(action.oldLocation) {
                    for (var i = action.oldLocation.line; i <= action.oldLocation.endLine; i++) {
                        if(!changedLineOld[i]) {
                            changedLineOld[i] = []
                        }
                        changedLineOld[i].push(action);
                    }
                }
            }

            console.log(changedLineNew, changedLineOld)

            var newTable = true;
            var countNoChange = 0;
            var output = "";
            var positionNew = 0;
            var positionOld = 0;

            var nbLineAround = 5;

            if(oldFile) {
                var indexOld = oldFile.indexOf("class");
                if(indexOld == -1) {
                    indexOld = oldFile.indexOf("interface");
                }
                var oldStartIndex = splitLine(oldFile.substring(0, indexOld)).length;
            } else {
                var oldStartIndex = -1;
            }
            if(newFile) {
                var indexNew = newFile.indexOf("class");
                if(indexNew == -1) {
                    indexNew = newFile.indexOf("interface");
                }
                var newStartIndex = splitLine(newFile.substring(0, indexNew)).length;
            } else {
                var newStartIndex = -1;
            }

            var nbNewLine = 0;
            var nbDeletedLine = 0;

            if(newStartIndex > oldStartIndex && newStartIndex != -1 && oldStartIndex != -1) {
                nbDeletedLine = oldStartIndex - newStartIndex;
            } else if(newStartIndex < oldStartIndex && newStartIndex != -1 && oldStartIndex != -1) {
                nbNewLine = newStartIndex - oldStartIndex;
            }

            for (var i = 0; i < Math.max(newLines.length, oldLines.length); i++) {
                var display = false;

                var newLineNumber = i + nbNewLine;
                var oldLineNumber = i + nbDeletedLine;

                var lineNew = changedLineNew[newLineNumber + 1];
                var lineOld = changedLineOld[oldLineNumber + 1];

                for (var k = newLineNumber; k <= newLineNumber + nbLineAround && !display; k++) {
                    if(changedLineNew.length > k  && changedLineNew[k + 1]) {
                        display = true;
                    }
                }
                for (var k = oldLineNumber; k <= oldLineNumber + nbLineAround && !display; k++) {
                     if(changedLineOld.length > k  && changedLineOld[k + 1]) {
                        display = true;
                    }
                }
                function genereteCodeDiff(line, actions, type) {
                    var output = "";
                    if(line == undefined) return output;
                    output += ("<pre><code>");

                    if(!actions || actions.length == 0) {
                        output += formatCode(line);
                    } else {
                        actions = actions.sort(function (a, b) {
                            if(type == "old") {
                                return a.oldLocation.sourceStart - b.oldLocation.sourceStart;
                            } else {
                                return a.newLocation.sourceStart - b.newLocation.sourceStart;
                            }
                        });
                        var action = actions[0];
                        var location = action.newLocation;
                        if(type == "old") {
                            location = action.oldLocation;
                        }
                        var currentPosition = positionNew;
                        if(type == "old") {
                            currentPosition = positionOld;
                        }
                        var diff = location.sourceStart - currentPosition;

                        output += formatCode(line.substring(0, diff));

                        var changedCode = line.substring(diff, location.sourceEnd - currentPosition + 1);
                        for (var l = 0; l < changedCode.length; l++) {
                            if(changedCode[l] != " " && changedCode[l] != "\t") {
                                break;
                            }
                        }
                        var contentBeforeChange = changedCode.substring(0, l);
                        var contentAfterChange = line.substring(location.sourceEnd - currentPosition + 1);
                        if(contentBeforeChange.trim().length == 0 &&
                            contentAfterChange.replace(";", "").trim().length == 0) {
                            if(action.action == "Delete" || (
                                action.action == "Move" && type == "old")) {
                                nbDeletedLine ++;
                            } else if(type == "new" && action.action != "Update") {
                                nbNewLine ++;
                            }
                        }
                        output += contentBeforeChange;
                        output += "<span class=\"" + action.action + "\">";
                        output += formatCode(changedCode.substring(l));
                        //console.log(oldFile.substring(location.sourceStart, location.sourceEnd + 1))
                        //console.log(changedCode.substring(l), changedCode)
                        output += "</span>";
                        output += formatCode(contentAfterChange);
                    }
                    output += "</code></pre>";
                    return output;
                }

                var hiddeNew = false;
                var hiddeOld = false;
                if(!display) {
                    if(!newTable) {
                        countNoChange ++;
                        output += "<tr>";
                        output += generateLineNumber(newLines[newLineNumber]!=null?newLineNumber:null);
                        output += "<td class=\"code\">";
                        output += genereteCodeDiff(newLines[newLineNumber], lineNew, "new");
                        output += "</td>";
                        output += generateLineNumber(oldLines[oldLineNumber]!=null?oldLineNumber:null);
                        output += "<td class=\"code\">";
                        output += genereteCodeDiff(oldLines[oldLineNumber], lineOld, "old");
                        output += "</td></tr>";
                    }
                } else {
                    if(newTable) {
                        output += generateTable();
                    }
                    newTable = false;
                    countNoChange = 0;

                    var actions = [];
                    if(lineNew) {
                        for (var l = lineNew.length - 1; l >= 0; l--) {
                            actions.push(lineNew[l]);
                        }
                    }
                    if(lineOld) {
                        for (var l = lineOld.length - 1; l >= 0; l--) {
                            actions.push(lineOld[l]);
                        }
                    }
                    
                    var tmpNbNew = nbNewLine;

                    var newCodeDiff = genereteCodeDiff(newLines[newLineNumber], lineNew, "new");
                    var diffNew = nbNewLine - tmpNbNew;

                    var tmpNbDel = nbDeletedLine;
                    var oldCodeDiff = genereteCodeDiff(oldLines[oldLineNumber], lineOld, "old");
                    var diffDel = nbDeletedLine - tmpNbDel;

                    output += "<tr>";
                    if(diffDel > diffNew) {
                        hiddeNew = true;
                        output += generateLineNumber();
                        output += "<td class=\"code\"></td>";
                    } else {
                        output += generateLineNumber(newLines[newLineNumber]!=null?newLineNumber: null);
                        output += "<td class=\"code\">";
                        output += newCodeDiff;
                        output += "</td>";
                    }
                    
                    if(diffNew > diffDel) {
                        hiddeOld = true;
                        output += generateLineNumber();
                        output += "<td class=\"code\"></td></tr>";
                    } else {
                        output += generateLineNumber(oldLines[oldLineNumber]!=null?oldLineNumber:null);
                        output += "<td class=\"code\">";
                        output += oldCodeDiff;
                        output += "</td></tr>";
                    }

                    if(hiddeOld || hiddeNew || (diffNew == diffDel && diffDel > 0) ) {
                         i--;
                    }
                    if(diffDel > 0 && hiddeOld) {
                        nbDeletedLine --;
                    } else if(diffNew > 0 && hiddeNew) {
                        nbNewLine --;
                    }
                }
                if((countNoChange >= nbLineAround || i >= Math.max(newLines.length, oldLines.length) - 1) && output != "") {
                    newTable = true;

                    output += ("</table>");

                    element.append(output + "<hr>");
                    //$compile(element.contents())(scope);
                    output = "";
                }
                if(!hiddeNew && newLines[newLineNumber] != undefined) {
                    positionNew += newLines[newLineNumber].length + 1;
                }
                if(!hiddeOld && oldLines[oldLineNumber] != undefined) {
                    positionOld += oldLines[oldLineNumber].length + 1;
                } 
            }
        }
    };
}).config(function ($mdThemingProvider) {

    // Configure a dark theme with primary foreground yellow

    $mdThemingProvider.theme('docs-dark', 'default')
        .dark();

});
